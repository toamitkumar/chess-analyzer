{"ast":null,"code":"import { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translate } from './util.js';\nimport { whitePov } from './board.js';\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nexport function render(s) {\n  const asWhite = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds()),\n    boardEl = s.dom.elements.board,\n    pieces = s.pieces,\n    curAnim = s.animation.current,\n    anims = curAnim ? curAnim.plan.anims : new Map(),\n    fadings = curAnim ? curAnim.plan.fadings : new Map(),\n    curDrag = s.draggable.current,\n    squares = computeSquareClasses(s),\n    samePieces = new Set(),\n    sameSquares = new Set(),\n    movedPieces = new Map(),\n    movedSquares = new Map(); // by class name\n  let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;\n  // walk over all board dom elements, apply animations and flag moved pieces\n  el = boardEl.firstChild;\n  while (el) {\n    k = el.cgKey;\n    if (isPieceNode(el)) {\n      pieceAtKey = pieces.get(k);\n      anim = anims.get(k);\n      fading = fadings.get(k);\n      elPieceName = el.cgPiece;\n      // if piece not being dragged anymore, remove dragging style\n      if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n        el.classList.remove('dragging');\n        translate(el, posToTranslate(key2pos(k), asWhite));\n        el.cgDragging = false;\n      }\n      // remove fading class if it still remains\n      if (!fading && el.cgFading) {\n        el.cgFading = false;\n        el.classList.remove('fading');\n      }\n      // there is now a piece at this dom key\n      if (pieceAtKey) {\n        // continue animation if already animating and same piece\n        // (otherwise it could animate a captured piece)\n        if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n          const pos = key2pos(k);\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n          el.classList.add('anim');\n          translate(el, posToTranslate(pos, asWhite));\n        } else if (el.cgAnimating) {\n          el.cgAnimating = false;\n          el.classList.remove('anim');\n          translate(el, posToTranslate(key2pos(k), asWhite));\n          if (s.addPieceZIndex) el.style.zIndex = posZIndex(key2pos(k), asWhite);\n        }\n        // same piece: flag as same\n        if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n          samePieces.add(k);\n        }\n        // different piece: flag as moved unless it is a fading piece\n        else {\n          if (fading && elPieceName === pieceNameOf(fading)) {\n            el.classList.add('fading');\n            el.cgFading = true;\n          } else {\n            appendValue(movedPieces, elPieceName, el);\n          }\n        }\n      }\n      // no piece: flag as moved\n      else {\n        appendValue(movedPieces, elPieceName, el);\n      }\n    } else if (isSquareNode(el)) {\n      const cn = el.className;\n      if (squares.get(k) === cn) sameSquares.add(k);else appendValue(movedSquares, cn, el);\n    }\n    el = el.nextSibling;\n  }\n  // walk over all squares in current set, apply dom changes to moved squares\n  // or append new squares\n  for (const [sk, className] of squares) {\n    if (!sameSquares.has(sk)) {\n      sMvdset = movedSquares.get(className);\n      sMvd = sMvdset && sMvdset.pop();\n      const translation = posToTranslate(key2pos(sk), asWhite);\n      if (sMvd) {\n        sMvd.cgKey = sk;\n        translate(sMvd, translation);\n      } else {\n        const squareNode = createEl('square', className);\n        squareNode.cgKey = sk;\n        translate(squareNode, translation);\n        boardEl.insertBefore(squareNode, boardEl.firstChild);\n      }\n    }\n  }\n  // walk over all pieces in current set, apply dom changes to moved pieces\n  // or append new pieces\n  for (const [k, p] of pieces) {\n    anim = anims.get(k);\n    if (!samePieces.has(k)) {\n      pMvdset = movedPieces.get(pieceNameOf(p));\n      pMvd = pMvdset && pMvdset.pop();\n      // a same piece was moved\n      if (pMvd) {\n        // apply dom changes\n        pMvd.cgKey = k;\n        if (pMvd.cgFading) {\n          pMvd.classList.remove('fading');\n          pMvd.cgFading = false;\n        }\n        const pos = key2pos(k);\n        if (s.addPieceZIndex) pMvd.style.zIndex = posZIndex(pos, asWhite);\n        if (anim) {\n          pMvd.cgAnimating = true;\n          pMvd.classList.add('anim');\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pMvd, posToTranslate(pos, asWhite));\n      }\n      // no piece in moved obj: insert the new piece\n      // assumes the new piece is not being dragged\n      else {\n        const pieceName = pieceNameOf(p),\n          pieceNode = createEl('piece', pieceName),\n          pos = key2pos(k);\n        pieceNode.cgPiece = pieceName;\n        pieceNode.cgKey = k;\n        if (anim) {\n          pieceNode.cgAnimating = true;\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pieceNode, posToTranslate(pos, asWhite));\n        if (s.addPieceZIndex) pieceNode.style.zIndex = posZIndex(pos, asWhite);\n        boardEl.appendChild(pieceNode);\n      }\n    }\n  }\n  // remove any element that remains in the moved sets\n  for (const nodes of movedPieces.values()) removeNodes(s, nodes);\n  for (const nodes of movedSquares.values()) removeNodes(s, nodes);\n}\nexport function renderResized(s) {\n  const asWhite = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds());\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if (isPieceNode(el) && !el.cgAnimating || isSquareNode(el)) {\n      translate(el, posToTranslate(key2pos(el.cgKey), asWhite));\n    }\n    el = el.nextSibling;\n  }\n}\nexport function updateBounds(s) {\n  const bounds = s.dom.elements.wrap.getBoundingClientRect();\n  const container = s.dom.elements.container;\n  const ratio = bounds.height / bounds.width;\n  const width = Math.floor(bounds.width * window.devicePixelRatio / 8) * 8 / window.devicePixelRatio;\n  const height = width * ratio;\n  container.style.width = width + 'px';\n  container.style.height = height + 'px';\n  s.dom.bounds.clear();\n  s.addDimensionsCssVarsTo?.style.setProperty('---cg-width', width + 'px');\n  s.addDimensionsCssVarsTo?.style.setProperty('---cg-height', height + 'px');\n}\nconst isPieceNode = el => el.tagName === 'PIECE';\nconst isSquareNode = el => el.tagName === 'SQUARE';\nfunction removeNodes(s, nodes) {\n  for (const node of nodes) s.dom.elements.board.removeChild(node);\n}\nfunction posZIndex(pos, asWhite) {\n  const minZ = 3;\n  const rank = pos[1];\n  const z = asWhite ? minZ + 7 - rank : minZ + rank;\n  return `${z}`;\n}\nconst pieceNameOf = piece => `${piece.color} ${piece.role}`;\nfunction computeSquareClasses(s) {\n  const squares = new Map();\n  if (s.lastMove && s.highlight.lastMove) for (const k of s.lastMove) {\n    addSquare(squares, k, 'last-move');\n  }\n  if (s.check && s.highlight.check) addSquare(squares, s.check, 'check');\n  if (s.selected) {\n    addSquare(squares, s.selected, 'selected');\n    if (s.movable.showDests) {\n      const dests = s.movable.dests?.get(s.selected);\n      if (dests) for (const k of dests) {\n        addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n      }\n      const pDests = s.premovable.customDests?.get(s.selected) ?? s.premovable.dests;\n      if (pDests) for (const k of pDests) {\n        addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n      }\n    }\n  }\n  const premove = s.premovable.current;\n  if (premove) for (const k of premove) addSquare(squares, k, 'current-premove');else if (s.predroppable.current) addSquare(squares, s.predroppable.current.key, 'current-premove');\n  const o = s.exploding;\n  if (o) for (const k of o.keys) addSquare(squares, k, 'exploding' + o.stage);\n  if (s.highlight.custom) {\n    s.highlight.custom.forEach((v, k) => {\n      addSquare(squares, k, v);\n    });\n  }\n  return squares;\n}\nfunction addSquare(squares, key, klass) {\n  const classes = squares.get(key);\n  if (classes) squares.set(key, `${classes} ${klass}`);else squares.set(key, klass);\n}\nfunction appendValue(map, key, value) {\n  const arr = map.get(key);\n  if (arr) arr.push(value);else map.set(key, [value]);\n}\n//# sourceMappingURL=render.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}