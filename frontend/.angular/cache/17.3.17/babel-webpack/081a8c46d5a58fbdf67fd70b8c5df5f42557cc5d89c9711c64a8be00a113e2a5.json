{"ast":null,"code":"import _asyncToGenerator from \"/Users/amit.kumar3/projects/chess-analysis/chessify/newfrontend/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\nimport { FEN, Position } from \"../model/Position.js\";\nimport { Svg } from \"../lib/Svg.js\";\nimport { EXTENSION_POINT } from \"../model/Extension.js\";\nimport { Utils } from \"../lib/Utils.js\";\n\n/*\n* Thanks to markosyan for the idea of the PromiseQueue\n* https://medium.com/@karenmarkosyan/how-to-manage-promises-into-dynamic-queue-with-vanilla-javascript-9d0d1f8d4df5\n*/\n\nexport const ANIMATION_EVENT_TYPE = {\n  start: \"start\",\n  frame: \"frame\",\n  end: \"end\"\n};\nexport class PromiseQueue {\n  constructor() {\n    this.queue = [];\n    this.workingOnPromise = false;\n    this.stop = false;\n  }\n  enqueue(promise) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this.queue.push({\n          promise,\n          resolve,\n          reject\n        });\n        _this.dequeue();\n      });\n    })();\n  }\n  dequeue() {\n    if (this.workingOnPromise) {\n      return;\n    }\n    if (this.stop) {\n      this.queue = [];\n      this.stop = false;\n      return;\n    }\n    const entry = this.queue.shift();\n    if (!entry) {\n      return;\n    }\n    try {\n      this.workingOnPromise = true;\n      entry.promise().then(value => {\n        this.workingOnPromise = false;\n        entry.resolve(value);\n        this.dequeue();\n      }).catch(err => {\n        this.workingOnPromise = false;\n        entry.reject(err);\n        this.dequeue();\n      });\n    } catch (err) {\n      this.workingOnPromise = false;\n      entry.reject(err);\n      this.dequeue();\n    }\n    return true;\n  }\n  destroy() {\n    this.stop = true;\n  }\n}\nconst CHANGE_TYPE = {\n  move: 0,\n  appear: 1,\n  disappear: 2\n};\nexport class PositionsAnimation {\n  constructor(view, fromPosition, toPosition, duration, callback) {\n    this.view = view;\n    if (fromPosition && toPosition) {\n      this.animatedElements = this.createAnimation(fromPosition.squares, toPosition.squares);\n      this.duration = duration;\n      this.callback = callback;\n      this.frameHandle = requestAnimationFrame(this.animationStep.bind(this));\n    } else {\n      console.error(\"fromPosition\", fromPosition, \"toPosition\", toPosition);\n    }\n    this.view.positionsAnimationTask = Utils.createTask();\n    this.view.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.animation, {\n      type: ANIMATION_EVENT_TYPE.start\n    });\n  }\n  static seekChanges(fromSquares, toSquares) {\n    const appearedList = [],\n      disappearedList = [],\n      changes = [];\n    for (let i = 0; i < 64; i++) {\n      const previousSquare = fromSquares[i];\n      const newSquare = toSquares[i];\n      if (newSquare !== previousSquare) {\n        if (newSquare) {\n          appearedList.push({\n            piece: newSquare,\n            index: i\n          });\n        }\n        if (previousSquare) {\n          disappearedList.push({\n            piece: previousSquare,\n            index: i\n          });\n        }\n      }\n    }\n    appearedList.forEach(appeared => {\n      let shortestDistance = 8;\n      let foundMoved = null;\n      disappearedList.forEach(disappeared => {\n        if (appeared.piece === disappeared.piece) {\n          const moveDistance = PositionsAnimation.squareDistance(appeared.index, disappeared.index);\n          if (moveDistance < shortestDistance) {\n            foundMoved = disappeared;\n            shortestDistance = moveDistance;\n          }\n        }\n      });\n      if (foundMoved) {\n        disappearedList.splice(disappearedList.indexOf(foundMoved), 1); // remove from disappearedList, because it is moved now\n        changes.push({\n          type: CHANGE_TYPE.move,\n          piece: appeared.piece,\n          atIndex: foundMoved.index,\n          toIndex: appeared.index\n        });\n      } else {\n        changes.push({\n          type: CHANGE_TYPE.appear,\n          piece: appeared.piece,\n          atIndex: appeared.index\n        });\n      }\n    });\n    disappearedList.forEach(disappeared => {\n      changes.push({\n        type: CHANGE_TYPE.disappear,\n        piece: disappeared.piece,\n        atIndex: disappeared.index\n      });\n    });\n    return changes;\n  }\n  createAnimation(fromSquares, toSquares) {\n    const changes = PositionsAnimation.seekChanges(fromSquares, toSquares);\n    const animatedElements = [];\n    changes.forEach(change => {\n      const animatedItem = {\n        type: change.type\n      };\n      switch (change.type) {\n        case CHANGE_TYPE.move:\n          animatedItem.element = this.view.getPieceElement(Position.indexToSquare(change.atIndex));\n          animatedItem.element.parentNode.appendChild(animatedItem.element); // move element to top layer\n          animatedItem.atPoint = this.view.indexToPoint(change.atIndex);\n          animatedItem.toPoint = this.view.indexToPoint(change.toIndex);\n          break;\n        case CHANGE_TYPE.appear:\n          animatedItem.element = this.view.drawPieceOnSquare(Position.indexToSquare(change.atIndex), change.piece);\n          animatedItem.element.style.opacity = 0;\n          break;\n        case CHANGE_TYPE.disappear:\n          animatedItem.element = this.view.getPieceElement(Position.indexToSquare(change.atIndex));\n          break;\n      }\n      animatedElements.push(animatedItem);\n    });\n    return animatedElements;\n  }\n  animationStep(time) {\n    if (!this.view || !this.view.chessboard.state) {\n      // board was destroyed\n      return;\n    }\n    if (!this.startTime) {\n      this.startTime = time;\n    }\n    const timeDiff = time - this.startTime;\n    if (timeDiff <= this.duration) {\n      this.frameHandle = requestAnimationFrame(this.animationStep.bind(this));\n    } else {\n      cancelAnimationFrame(this.frameHandle);\n      this.animatedElements.forEach(animatedItem => {\n        if (animatedItem.type === CHANGE_TYPE.disappear) {\n          Svg.removeElement(animatedItem.element);\n        }\n      });\n      this.view.positionsAnimationTask.resolve();\n      this.view.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.animation, {\n        type: ANIMATION_EVENT_TYPE.end\n      });\n      this.callback();\n      return;\n    }\n    const t = Math.min(1, timeDiff / this.duration);\n    let progress = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // easeInOut\n    if (isNaN(progress) || progress > 0.99) {\n      progress = 1;\n    }\n    this.animatedElements.forEach(animatedItem => {\n      if (animatedItem.element) {\n        switch (animatedItem.type) {\n          case CHANGE_TYPE.move:\n            animatedItem.element.transform.baseVal.removeItem(0);\n            const transform = this.view.svg.createSVGTransform();\n            transform.setTranslate(animatedItem.atPoint.x + (animatedItem.toPoint.x - animatedItem.atPoint.x) * progress, animatedItem.atPoint.y + (animatedItem.toPoint.y - animatedItem.atPoint.y) * progress);\n            animatedItem.element.transform.baseVal.appendItem(transform);\n            break;\n          case CHANGE_TYPE.appear:\n            animatedItem.element.style.opacity = Math.round(progress * 100) / 100;\n            break;\n          case CHANGE_TYPE.disappear:\n            animatedItem.element.style.opacity = Math.round((1 - progress) * 100) / 100;\n            break;\n        }\n      } else {\n        console.warn(\"animatedItem has no element\", animatedItem);\n      }\n    });\n    this.view.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.animation, {\n      type: ANIMATION_EVENT_TYPE.frame,\n      progress: progress\n    });\n  }\n  static squareDistance(index1, index2) {\n    const file1 = index1 % 8;\n    const rank1 = Math.floor(index1 / 8);\n    const file2 = index2 % 8;\n    const rank2 = Math.floor(index2 / 8);\n    return Math.max(Math.abs(rank2 - rank1), Math.abs(file2 - file1));\n  }\n}\nexport class PositionAnimationsQueue extends PromiseQueue {\n  constructor(chessboard) {\n    super();\n    this.chessboard = chessboard;\n  }\n  enqueuePositionChange(positionFrom, positionTo, animated) {\n    var _superprop_getEnqueue = () => super.enqueue,\n      _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (positionFrom.getFen() === positionTo.getFen()) {\n        return Promise.resolve();\n      } else {\n        return _superprop_getEnqueue().call(_this2, () => new Promise(resolve => {\n          let duration = animated ? _this2.chessboard.props.style.animationDuration : 0;\n          if (_this2.queue.length > 0) {\n            duration = duration / (1 + Math.pow(_this2.queue.length / 5, 2));\n          }\n          new PositionsAnimation(_this2.chessboard.view, positionFrom, positionTo, animated ? duration : 0, () => {\n            if (_this2.chessboard.view) {\n              // if destroyed, no view anymore\n              _this2.chessboard.view.redrawPieces(positionTo.squares);\n            }\n            resolve();\n          });\n        }));\n      }\n    })();\n  }\n  enqueueTurnBoard(position, color, animated) {\n    var _superprop_getEnqueue2 = () => super.enqueue,\n      _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _superprop_getEnqueue2().call(_this3, () => new Promise(resolve => {\n        const emptyPosition = new Position(FEN.empty);\n        let duration = animated ? _this3.chessboard.props.style.animationDuration : 0;\n        if (_this3.queue.length > 0) {\n          duration = duration / (1 + Math.pow(_this3.queue.length / 5, 2));\n        }\n        new PositionsAnimation(_this3.chessboard.view, position, emptyPosition, animated ? duration : 0, () => {\n          _this3.chessboard.state.orientation = color;\n          _this3.chessboard.view.redrawBoard();\n          _this3.chessboard.view.redrawPieces(emptyPosition.squares);\n          new PositionsAnimation(_this3.chessboard.view, emptyPosition, position, animated ? duration : 0, () => {\n            _this3.chessboard.view.redrawPieces(position.squares);\n            resolve();\n          });\n        });\n      }));\n    })();\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}