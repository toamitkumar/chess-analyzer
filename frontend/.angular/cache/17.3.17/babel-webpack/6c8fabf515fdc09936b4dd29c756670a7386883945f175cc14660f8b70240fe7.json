{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Chess } from 'chess.js';\nimport { Chessground } from '@lichess-org/chessground';\nimport { MoveQuality, MOVE_QUALITY_COLORS } from '../../constants/move-quality.constants';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nconst _c0 = [\"chessBoard\"];\nfunction ChessBoardComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\")(1, \"div\", 16);\n    i0.ɵɵelement(2, \"div\", 17);\n    i0.ɵɵelementStart(3, \"span\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r1.getPlayerNameClass(\"white\"));\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r1.whitePlayer);\n  }\n}\nfunction ChessBoardComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\")(1, \"div\", 16);\n    i0.ɵɵelement(2, \"div\", 18);\n    i0.ɵɵelementStart(3, \"span\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r1.getPlayerNameClass(\"black\"));\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r1.blackPlayer);\n  }\n}\nexport let ChessBoardComponent = /*#__PURE__*/(() => {\n  class ChessBoardComponent {\n    constructor() {\n      this.moves = [];\n      this.currentMoveIndex = -1;\n      this.initialPosition = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n      this.whitePlayer = '';\n      this.blackPlayer = '';\n      this.moveChanged = new EventEmitter();\n      this.board = null;\n      this.internalMoveIndex = -1;\n      this.currentMove = null;\n      this.isFlipped = false;\n      // Make Math available in template\n      this.Math = Math;\n      this.handleKeyPress = event => {\n        switch (event.key) {\n          case 'ArrowLeft':\n            event.preventDefault();\n            this.previousMove();\n            break;\n          case 'ArrowRight':\n            event.preventDefault();\n            this.nextMove();\n            break;\n          case 'Home':\n            event.preventDefault();\n            this.goToStart();\n            break;\n          case 'End':\n            event.preventDefault();\n            this.goToEnd();\n            break;\n        }\n      };\n    }\n    ngOnInit() {\n      console.log('ChessBoardComponent ngOnInit called');\n      this.game = new Chess(this.initialPosition);\n      this.setupKeyboardListeners();\n    }\n    ngOnChanges(changes) {\n      if (changes['moves'] && this.moves) {\n        // Reset to initial position when moves change\n        this.internalMoveIndex = -1;\n        this.currentMove = null;\n        if (this.game) {\n          this.game.reset();\n          this.game.load(this.initialPosition);\n        }\n      }\n      if (changes['currentMoveIndex'] && changes['currentMoveIndex'].currentValue !== undefined) {\n        // Update board position when currentMoveIndex input changes\n        this.goToMove(changes['currentMoveIndex'].currentValue);\n      }\n    }\n    ngAfterViewInit() {\n      console.log('Chess board component initializing...');\n      setTimeout(() => {\n        this.initializeBoard();\n      }, 100);\n    }\n    initializeBoard() {\n      console.log('Initializing Chessground board...');\n      const element = this.chessBoardElement?.nativeElement;\n      if (!element) {\n        console.error('Chess board element not found');\n        return;\n      }\n      console.log('Board element:', element);\n      try {\n        const config = {\n          fen: this.initialPosition,\n          orientation: this.isFlipped ? 'black' : 'white',\n          viewOnly: true,\n          coordinates: true,\n          highlight: {\n            lastMove: true,\n            check: true\n          },\n          animation: {\n            enabled: true,\n            duration: 200\n          },\n          drawable: {\n            enabled: true,\n            visible: true\n          }\n        };\n        console.log('Creating Chessground with config:', config);\n        this.board = Chessground(element, config);\n        console.log('Chessground board created successfully');\n        // Force a redraw and set position\n        if (this.board) {\n          this.board.set({\n            fen: this.initialPosition\n          });\n          this.board.redrawAll();\n        }\n      } catch (error) {\n        console.error('Failed to initialize Chessground:', error);\n      }\n    }\n    ngOnDestroy() {\n      this.removeKeyboardListeners();\n      if (this.board) {\n        this.board.destroy();\n      }\n    }\n    setupKeyboardListeners() {\n      document.addEventListener('keydown', this.handleKeyPress);\n    }\n    removeKeyboardListeners() {\n      document.removeEventListener('keydown', this.handleKeyPress);\n    }\n    goToStart() {\n      this.goToMove(-1);\n    }\n    previousMove() {\n      if (this.currentMoveIndex > -1) {\n        this.goToMove(this.currentMoveIndex - 1);\n      }\n    }\n    nextMove() {\n      if (this.currentMoveIndex < this.moves.length - 1) {\n        this.goToMove(this.currentMoveIndex + 1);\n      }\n    }\n    goToEnd() {\n      this.goToMove(this.moves.length - 1);\n    }\n    goToMove(moveIndex) {\n      this.currentMoveIndex = moveIndex;\n      this.currentMove = moveIndex >= 0 ? this.moves[moveIndex] : null;\n      // Reset game to initial position\n      this.game = new Chess(this.initialPosition);\n      // Play moves up to current position\n      let lastMove;\n      for (let i = 0; i <= moveIndex; i++) {\n        if (this.moves[i]) {\n          try {\n            const move = this.game.move(this.moves[i].move);\n            if (i === moveIndex) {\n              lastMove = {\n                from: move.from,\n                to: move.to\n              };\n            }\n          } catch (error) {\n            console.error('Invalid move:', this.moves[i].move, error);\n            break;\n          }\n        }\n      }\n      // Update board position with move quality highlighting\n      if (this.board) {\n        this.board.set({\n          fen: this.game.fen(),\n          lastMove: lastMove ? [lastMove.from, lastMove.to] : undefined\n        });\n        // Add move quality highlighting\n        if (lastMove && this.currentMove) {\n          this.highlightMoveQuality(lastMove.from, lastMove.to);\n        }\n      }\n      // Emit move change event\n      this.moveChanged.emit(moveIndex);\n    }\n    highlightMoveQuality(from, to) {\n      if (!this.board || !this.currentMove) return;\n      const quality = this.getMoveQuality();\n      const icon = this.getMoveQualityIcon(quality);\n      const color = this.getMoveQualityColor(quality);\n      if (icon) {\n        // Add move quality annotation at top-right corner of square\n        this.board.set({\n          drawable: {\n            autoShapes: [{\n              orig: to,\n              customSvg: {\n                html: `<circle cx=\"85%\" cy=\"15%\" r=\"16\" fill=\"${color}\" stroke=\"white\" stroke-width=\"2\"/>\n                       <text x=\"85%\" y=\"20%\" text-anchor=\"middle\" dominant-baseline=\"central\" \n                             font-size=\"18\" font-weight=\"bold\" fill=\"white\">\n                         ${icon}\n                       </text>`\n              }\n            }]\n          }\n        });\n      }\n    }\n    getMoveQualityIcon(quality) {\n      const icons = {\n        [MoveQuality.BOOK]: 'B',\n        [MoveQuality.BEST]: '★',\n        [MoveQuality.EXCELLENT]: '!',\n        [MoveQuality.GOOD]: '○',\n        [MoveQuality.INACCURACY]: '?!',\n        [MoveQuality.MISTAKE]: '?',\n        [MoveQuality.BLUNDER]: '??'\n      };\n      return icons[quality] || '';\n    }\n    getMoveQualityColor(quality) {\n      const colors = MOVE_QUALITY_COLORS[quality];\n      return colors?.background || '#666';\n    }\n    formatEvaluation(evaluation) {\n      if (Math.abs(evaluation) > 900) {\n        return evaluation > 0 ? '+M' : '-M';\n      }\n      return (evaluation / 100).toFixed(1);\n    }\n    getEvaluationClass() {\n      if (!this.currentMove) return 'eval-neutral';\n      const evaluation = this.currentMove.evaluation;\n      if (evaluation > 50) return 'eval-positive';\n      if (evaluation < -50) return 'eval-negative';\n      return 'eval-neutral';\n    }\n    getMoveQuality() {\n      if (!this.currentMove) return '';\n      // Check for book moves (first 10 moves typically)\n      if (this.currentMoveIndex < 10) return MoveQuality.BOOK;\n      // Check for best moves (low centipawn loss)\n      if (this.currentMove.centipawn_loss <= 5) return MoveQuality.BEST;\n      if (this.currentMove.is_blunder) return MoveQuality.BLUNDER;\n      if (this.currentMove.is_mistake) return MoveQuality.MISTAKE;\n      if (this.currentMove.is_inaccuracy) return MoveQuality.INACCURACY;\n      if (this.currentMove.centipawn_loss <= 10) return MoveQuality.EXCELLENT;\n      return MoveQuality.GOOD;\n    }\n    getMoveQualityStyle() {\n      const quality = this.getMoveQuality();\n      const colors = MOVE_QUALITY_COLORS[quality];\n      if (!colors) return {};\n      return {\n        'background-color': colors.background,\n        'color': colors.text,\n        'border-color': colors.border\n      };\n    }\n    getMoveQualityClass() {\n      const quality = this.getMoveQuality().toLowerCase();\n      return `move-${quality}`;\n    }\n    flipBoard() {\n      this.isFlipped = !this.isFlipped;\n      if (this.board) {\n        this.board.set({\n          orientation: this.isFlipped ? 'black' : 'white'\n        });\n      }\n    }\n    getPlayerNameClass(player) {\n      const baseClass = 'player-name';\n      const colorClass = `player-${player}`;\n      let positionClass;\n      if (player === 'white') {\n        positionClass = this.isFlipped ? 'top-left' : 'bottom-left';\n      } else {\n        positionClass = this.isFlipped ? 'bottom-left' : 'top-left';\n      }\n      return `${baseClass} ${colorClass} ${positionClass}`;\n    }\n    getBoardHeight() {\n      const viewportWidth = window.innerWidth;\n      if (viewportWidth < 640) return Math.min(400, viewportWidth - 32);\n      if (viewportWidth < 1024) return Math.min(520, viewportWidth * 0.6);\n      return 520;\n    }\n    static {\n      this.ɵfac = function ChessBoardComponent_Factory(t) {\n        return new (t || ChessBoardComponent)();\n      };\n    }\n    static {\n      this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n        type: ChessBoardComponent,\n        selectors: [[\"app-chess-board\"]],\n        viewQuery: function ChessBoardComponent_Query(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵviewQuery(_c0, 7);\n          }\n          if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chessBoardElement = _t.first);\n          }\n        },\n        inputs: {\n          moves: \"moves\",\n          currentMoveIndex: \"currentMoveIndex\",\n          initialPosition: \"initialPosition\",\n          whitePlayer: \"whitePlayer\",\n          blackPlayer: \"blackPlayer\"\n        },\n        outputs: {\n          moveChanged: \"moveChanged\"\n        },\n        standalone: true,\n        features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n        decls: 24,\n        vars: 8,\n        consts: [[\"chessBoard\", \"\"], [1, \"chess-board-container\"], [1, \"board-and-evaluation\"], [1, \"chess-board-wrapper\"], [3, \"class\", 4, \"ngIf\"], [1, \"board-with-eval\"], [1, \"chess-board\"], [1, \"board-controls\"], [1, \"control-btn\", 3, \"click\", \"disabled\"], [\"fill\", \"none\", \"stroke\", \"currentColor\", \"viewBox\", \"0 0 24 24\", 1, \"h-5\", \"w-5\"], [\"stroke-linecap\", \"round\", \"stroke-linejoin\", \"round\", \"stroke-width\", \"2\", \"d\", \"M11 19l-7-7 7-7m8 14l-7-7 7-7\"], [\"stroke-linecap\", \"round\", \"stroke-linejoin\", \"round\", \"stroke-width\", \"2\", \"d\", \"M15 19l-7-7 7-7\"], [\"title\", \"Flip Board\", 1, \"control-btn\", \"flip-btn\", 3, \"click\"], [\"stroke-linecap\", \"round\", \"stroke-linejoin\", \"round\", \"stroke-width\", \"2\", \"d\", \"M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4\"], [\"stroke-linecap\", \"round\", \"stroke-linejoin\", \"round\", \"stroke-width\", \"2\", \"d\", \"M9 5l7 7-7 7\"], [\"stroke-linecap\", \"round\", \"stroke-linejoin\", \"round\", \"stroke-width\", \"2\", \"d\", \"M13 5l7 7-7 7M5 5l7 7-7 7\"], [1, \"flex\", \"items-center\", \"gap-2\"], [1, \"w-3\", \"h-3\", \"bg-white\", \"border\", \"border-gray-400\", \"rounded-sm\"], [1, \"w-3\", \"h-3\", \"bg-gray-800\", \"border\", \"border-gray-600\", \"rounded-sm\"]],\n        template: function ChessBoardComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            const _r1 = i0.ɵɵgetCurrentView();\n            i0.ɵɵelementStart(0, \"div\", 1)(1, \"div\", 2)(2, \"div\", 3);\n            i0.ɵɵtemplate(3, ChessBoardComponent_div_3_Template, 5, 3, \"div\", 4)(4, ChessBoardComponent_div_4_Template, 5, 3, \"div\", 4);\n            i0.ɵɵelementStart(5, \"div\", 5);\n            i0.ɵɵelement(6, \"div\", 6, 0);\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(8, \"div\", 7)(9, \"button\", 8);\n            i0.ɵɵlistener(\"click\", function ChessBoardComponent_Template_button_click_9_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.goToStart());\n            });\n            i0.ɵɵnamespaceSVG();\n            i0.ɵɵelementStart(10, \"svg\", 9);\n            i0.ɵɵelement(11, \"path\", 10);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵnamespaceHTML();\n            i0.ɵɵelementStart(12, \"button\", 8);\n            i0.ɵɵlistener(\"click\", function ChessBoardComponent_Template_button_click_12_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.previousMove());\n            });\n            i0.ɵɵnamespaceSVG();\n            i0.ɵɵelementStart(13, \"svg\", 9);\n            i0.ɵɵelement(14, \"path\", 11);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵnamespaceHTML();\n            i0.ɵɵelementStart(15, \"button\", 12);\n            i0.ɵɵlistener(\"click\", function ChessBoardComponent_Template_button_click_15_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.flipBoard());\n            });\n            i0.ɵɵnamespaceSVG();\n            i0.ɵɵelementStart(16, \"svg\", 9);\n            i0.ɵɵelement(17, \"path\", 13);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵnamespaceHTML();\n            i0.ɵɵelementStart(18, \"button\", 8);\n            i0.ɵɵlistener(\"click\", function ChessBoardComponent_Template_button_click_18_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.nextMove());\n            });\n            i0.ɵɵnamespaceSVG();\n            i0.ɵɵelementStart(19, \"svg\", 9);\n            i0.ɵɵelement(20, \"path\", 14);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵnamespaceHTML();\n            i0.ɵɵelementStart(21, \"button\", 8);\n            i0.ɵɵlistener(\"click\", function ChessBoardComponent_Template_button_click_21_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.goToEnd());\n            });\n            i0.ɵɵnamespaceSVG();\n            i0.ɵɵelementStart(22, \"svg\", 9);\n            i0.ɵɵelement(23, \"path\", 15);\n            i0.ɵɵelementEnd()()()();\n          }\n          if (rf & 2) {\n            i0.ɵɵadvance(2);\n            i0.ɵɵclassProp(\"flipped\", ctx.isFlipped);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.whitePlayer);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.blackPlayer);\n            i0.ɵɵadvance(5);\n            i0.ɵɵproperty(\"disabled\", ctx.internalMoveIndex === 0);\n            i0.ɵɵadvance(3);\n            i0.ɵɵproperty(\"disabled\", ctx.internalMoveIndex === 0);\n            i0.ɵɵadvance(6);\n            i0.ɵɵproperty(\"disabled\", ctx.currentMoveIndex >= ctx.moves.length - 1);\n            i0.ɵɵadvance(3);\n            i0.ɵɵproperty(\"disabled\", ctx.currentMoveIndex >= ctx.moves.length - 1);\n          }\n        },\n        dependencies: [CommonModule, i1.NgIf],\n        styles: [\".chess-board-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;gap:1rem;padding:1rem;max-width:100%}.board-and-evaluation[_ngcontent-%COMP%]{display:flex;align-items:flex-start;gap:.25rem}.chess-board-wrapper[_ngcontent-%COMP%]{position:relative;width:clamp(360px,60vw,520px);height:clamp(360px,60vw,520px);aspect-ratio:1}.board-with-eval[_ngcontent-%COMP%]{display:flex;align-items:flex-start;gap:.25rem;width:100%;height:100%}.chess-board[_ngcontent-%COMP%]{width:100%;height:100%;min-width:320px;min-height:320px;background:#f0d9b5}[_nghost-%COMP%]     cg-board{width:100%!important;height:100%!important;display:block!important}[_nghost-%COMP%]     cg-container{width:100%!important;height:100%!important;display:block!important}[_nghost-%COMP%]     .move-quality-annotation{pointer-events:none;z-index:100}[_nghost-%COMP%]     .move-quality-annotation text{font-family:Arial,sans-serif;text-shadow:1px 1px 2px rgba(0,0,0,.8)}.evaluation-section[_ngcontent-%COMP%]{display:flex;height:100%}.player-name[_ngcontent-%COMP%]{position:absolute;z-index:20;border-radius:calc(var(--radius) - 2px);padding:.5rem .75rem;font-size:.875rem;line-height:1.25rem;font-weight:600;border-width:1px;--tw-border-opacity: 1;border-color:rgb(229 231 235 / var(--tw-border-opacity, 1));background-color:#ffffffe6;--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow);--tw-backdrop-blur: blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.2s;animation-duration:.2s;min-width:120px;text-align:center}.player-name[_ngcontent-%COMP%]:hover{--tw-scale-x: 1.05;--tw-scale-y: 1.05;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1));--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.player-name.bottom-left[_ngcontent-%COMP%]{bottom:-40px;left:0}.player-name.top-left[_ngcontent-%COMP%]{top:-40px;left:0}.player-name.player-white[_ngcontent-%COMP%]{--tw-border-opacity: 1;border-color:rgb(209 213 219 / var(--tw-border-opacity, 1));--tw-text-opacity: 1;color:rgb(31 41 55 / var(--tw-text-opacity, 1));background:linear-gradient(135deg,#fff,#f8f9fa)}.player-name.player-black[_ngcontent-%COMP%]{--tw-border-opacity: 1;border-color:rgb(75 85 99 / var(--tw-border-opacity, 1));--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1));background:linear-gradient(135deg,#343a40,#212529)}.board-controls[_ngcontent-%COMP%]{margin-top:1rem;display:flex;align-items:center;justify-content:center;gap:.5rem;border-radius:var(--radius);border-width:1px;--tw-border-opacity: 1;border-color:rgb(229 231 235 / var(--tw-border-opacity, 1));--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1));padding:.5rem;--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.control-btn[_ngcontent-%COMP%]{display:flex;height:2.5rem;width:2.5rem;align-items:center;justify-content:center;border-radius:calc(var(--radius) - 2px);--tw-bg-opacity: 1;background-color:rgb(243 244 246 / var(--tw-bg-opacity, 1));--tw-text-opacity: 1;color:rgb(55 65 81 / var(--tw-text-opacity, 1))}.control-btn[_ngcontent-%COMP%]:hover{--tw-bg-opacity: 1;background-color:rgb(229 231 235 / var(--tw-bg-opacity, 1))}.control-btn[_ngcontent-%COMP%]{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.2s;animation-duration:.2s}.control-btn[_ngcontent-%COMP%]:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity, 1))}.control-btn[_ngcontent-%COMP%]:hover{--tw-scale-x: 1.05;--tw-scale-y: 1.05;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.control-btn[_ngcontent-%COMP%]:disabled{cursor:not-allowed;opacity:.5}.flip-btn[_ngcontent-%COMP%]{--tw-bg-opacity: 1;background-color:rgb(219 234 254 / var(--tw-bg-opacity, 1));--tw-text-opacity: 1;color:rgb(29 78 216 / var(--tw-text-opacity, 1))}.flip-btn[_ngcontent-%COMP%]:hover{--tw-bg-opacity: 1;background-color:rgb(191 219 254 / var(--tw-bg-opacity, 1))}.evaluation-section[_ngcontent-%COMP%]{margin-top:1rem;display:flex;justify-content:center}@media (max-width: 640px){.chess-board-container[_ngcontent-%COMP%]{gap:.5rem;padding:.5rem}.board-and-evaluation[_ngcontent-%COMP%]{flex-direction:column;gap:.5rem}.chess-board-wrapper[_ngcontent-%COMP%]{width:calc(100vw - 32px);height:calc(100vw - 32px);max-width:360px;max-height:360px}.evaluation-section[_ngcontent-%COMP%]{height:auto}.player-name[_ngcontent-%COMP%]{padding:.25rem .5rem;font-size:.75rem;line-height:1rem;min-width:100px}.control-btn[_ngcontent-%COMP%]{height:2rem;width:2rem}}\"]\n      });\n    }\n  }\n  return ChessBoardComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}