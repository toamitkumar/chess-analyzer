{"ast":null,"code":"import * as board from './board.js';\nimport { write as fenWrite } from './fen.js';\nimport { configure, applyAnimation } from './config.js';\nimport { anim, render } from './anim.js';\nimport { cancel as dragCancel, dragNewPiece } from './drag.js';\nimport { explosion } from './explosion.js';\n// see API types and documentations in dts/api.d.ts\nexport function start(state, redrawAll) {\n  function toggleOrientation() {\n    board.toggleOrientation(state);\n    redrawAll();\n  }\n  return {\n    set(config) {\n      if (config.orientation && config.orientation !== state.orientation) toggleOrientation();\n      applyAnimation(state, config);\n      (config.fen ? anim : render)(state => configure(state, config), state);\n    },\n    state,\n    getFen: () => fenWrite(state.pieces),\n    toggleOrientation,\n    setPieces(pieces) {\n      anim(state => board.setPieces(state, pieces), state);\n    },\n    selectSquare(key, force) {\n      if (key) anim(state => board.selectSquare(state, key, force), state);else if (state.selected) {\n        board.unselect(state);\n        state.dom.redraw();\n      }\n    },\n    move(orig, dest) {\n      anim(state => board.baseMove(state, orig, dest), state);\n    },\n    newPiece(piece, key) {\n      anim(state => board.baseNewPiece(state, piece, key), state);\n    },\n    playPremove() {\n      if (state.premovable.current) {\n        if (anim(board.playPremove, state)) return true;\n        // if the premove couldn't be played, redraw to clear it up\n        state.dom.redraw();\n      }\n      return false;\n    },\n    playPredrop(validate) {\n      if (state.predroppable.current) {\n        const result = board.playPredrop(state, validate);\n        state.dom.redraw();\n        return result;\n      }\n      return false;\n    },\n    cancelPremove() {\n      render(board.unsetPremove, state);\n    },\n    cancelPredrop() {\n      render(board.unsetPredrop, state);\n    },\n    cancelMove() {\n      render(state => {\n        board.cancelMove(state);\n        dragCancel(state);\n      }, state);\n    },\n    stop() {\n      render(state => {\n        board.stop(state);\n        dragCancel(state);\n      }, state);\n    },\n    explode(keys) {\n      explosion(state, keys);\n    },\n    setAutoShapes(shapes) {\n      render(state => state.drawable.autoShapes = shapes, state);\n    },\n    setShapes(shapes) {\n      render(state => state.drawable.shapes = shapes.slice(), state);\n    },\n    getKeyAtDomPos(pos) {\n      return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());\n    },\n    redrawAll,\n    dragNewPiece(piece, event, force) {\n      dragNewPiece(state, piece, event, force);\n    },\n    destroy() {\n      board.stop(state);\n      state.dom.unbind && state.dom.unbind();\n      state.dom.destroyed = true;\n    }\n  };\n}\n//# sourceMappingURL=api.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}