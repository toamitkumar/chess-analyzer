{"ast":null,"code":"import { pos2key, key2pos, opposite, distanceSq, allPos, computeSquareCenter, queenDir, knightDir, samePos, pos2keyUnsafe } from './util.js';\nimport { premove } from './premove.js';\nexport function callUserFunction(f, ...args) {\n  if (f) setTimeout(() => f(...args), 1);\n}\nexport function toggleOrientation(state) {\n  state.orientation = opposite(state.orientation);\n  state.animation.current = state.draggable.current = state.selected = undefined;\n}\nexport function reset(state) {\n  state.lastMove = undefined;\n  unselect(state);\n  unsetPremove(state);\n  unsetPredrop(state);\n}\nexport function setPieces(state, pieces) {\n  for (const [key, piece] of pieces) {\n    if (piece) state.pieces.set(key, piece);else state.pieces.delete(key);\n  }\n}\nexport function setCheck(state, color) {\n  state.check = undefined;\n  if (color === true) color = state.turnColor;\n  if (color) for (const [k, p] of state.pieces) {\n    if (p.role === 'king' && p.color === color) {\n      state.check = k;\n    }\n  }\n}\nfunction setPremove(state, orig, dest, meta) {\n  unsetPredrop(state);\n  state.premovable.current = [orig, dest];\n  callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\nexport function unsetPremove(state) {\n  if (state.premovable.current) {\n    state.premovable.current = undefined;\n    callUserFunction(state.premovable.events.unset);\n  }\n}\nfunction setPredrop(state, role, key) {\n  unsetPremove(state);\n  state.predroppable.current = {\n    role,\n    key\n  };\n  callUserFunction(state.predroppable.events.set, role, key);\n}\nexport function unsetPredrop(state) {\n  const pd = state.predroppable;\n  if (pd.current) {\n    pd.current = undefined;\n    callUserFunction(pd.events.unset);\n  }\n}\nfunction tryAutoCastle(state, orig, dest) {\n  if (!state.autoCastle) return false;\n  const king = state.pieces.get(orig);\n  if (!king || king.role !== 'king') return false;\n  const origPos = key2pos(orig);\n  const destPos = key2pos(dest);\n  if (origPos[1] !== 0 && origPos[1] !== 7 || origPos[1] !== destPos[1]) return false;\n  if (origPos[0] === 4 && !state.pieces.has(dest)) {\n    if (destPos[0] === 6) dest = pos2keyUnsafe([7, destPos[1]]);else if (destPos[0] === 2) dest = pos2keyUnsafe([0, destPos[1]]);\n  }\n  const rook = state.pieces.get(dest);\n  if (!rook || rook.color !== king.color || rook.role !== 'rook') return false;\n  state.pieces.delete(orig);\n  state.pieces.delete(dest);\n  if (origPos[0] < destPos[0]) {\n    state.pieces.set(pos2keyUnsafe([6, destPos[1]]), king);\n    state.pieces.set(pos2keyUnsafe([5, destPos[1]]), rook);\n  } else {\n    state.pieces.set(pos2keyUnsafe([2, destPos[1]]), king);\n    state.pieces.set(pos2keyUnsafe([3, destPos[1]]), rook);\n  }\n  return true;\n}\nexport function baseMove(state, orig, dest) {\n  const origPiece = state.pieces.get(orig),\n    destPiece = state.pieces.get(dest);\n  if (orig === dest || !origPiece) return false;\n  const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n  if (dest === state.selected) unselect(state);\n  callUserFunction(state.events.move, orig, dest, captured);\n  if (!tryAutoCastle(state, orig, dest)) {\n    state.pieces.set(dest, origPiece);\n    state.pieces.delete(orig);\n  }\n  state.lastMove = [orig, dest];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  return captured || true;\n}\nexport function baseNewPiece(state, piece, key, force) {\n  if (state.pieces.has(key)) {\n    if (force) state.pieces.delete(key);else return false;\n  }\n  callUserFunction(state.events.dropNewPiece, piece, key);\n  state.pieces.set(key, piece);\n  state.lastMove = [key];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  state.movable.dests = undefined;\n  state.turnColor = opposite(state.turnColor);\n  return true;\n}\nfunction baseUserMove(state, orig, dest) {\n  const result = baseMove(state, orig, dest);\n  if (result) {\n    state.movable.dests = undefined;\n    state.turnColor = opposite(state.turnColor);\n    state.animation.current = undefined;\n  }\n  return result;\n}\nexport function userMove(state, orig, dest) {\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const holdTime = state.hold.stop();\n      unselect(state);\n      const metadata = {\n        premove: false,\n        ctrlKey: state.stats.ctrlKey,\n        holdTime\n      };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      return true;\n    }\n  } else if (canPremove(state, orig, dest)) {\n    setPremove(state, orig, dest, {\n      ctrlKey: state.stats.ctrlKey\n    });\n    unselect(state);\n    return true;\n  }\n  unselect(state);\n  return false;\n}\nexport function dropNewPiece(state, orig, dest, force) {\n  const piece = state.pieces.get(orig);\n  if (piece && (canDrop(state, orig, dest) || force)) {\n    state.pieces.delete(orig);\n    baseNewPiece(state, piece, dest, force);\n    callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n      premove: false,\n      predrop: false\n    });\n  } else if (piece && canPredrop(state, orig, dest)) {\n    setPredrop(state, piece.role, dest);\n  } else {\n    unsetPremove(state);\n    unsetPredrop(state);\n  }\n  state.pieces.delete(orig);\n  unselect(state);\n}\nexport function selectSquare(state, key, force) {\n  callUserFunction(state.events.select, key);\n  if (state.selected) {\n    if (state.selected === key && !state.draggable.enabled) {\n      unselect(state);\n      state.hold.cancel();\n      return;\n    } else if ((state.selectable.enabled || force) && state.selected !== key) {\n      if (userMove(state, state.selected, key)) {\n        state.stats.dragged = false;\n        return;\n      }\n    }\n  }\n  if ((state.selectable.enabled || state.draggable.enabled) && (isMovable(state, key) || isPremovable(state, key))) {\n    setSelected(state, key);\n    state.hold.start();\n  }\n}\nexport function setSelected(state, key) {\n  state.selected = key;\n  if (!isPremovable(state, key)) state.premovable.dests = undefined;else if (!state.premovable.customDests) state.premovable.dests = premove(state, key);\n  // calculate chess premoves if custom premoves are not passed\n}\nexport function unselect(state) {\n  state.selected = undefined;\n  state.premovable.dests = undefined;\n  state.hold.cancel();\n}\nfunction isMovable(state, orig) {\n  const piece = state.pieces.get(orig);\n  return !!piece && (state.movable.color === 'both' || state.movable.color === piece.color && state.turnColor === piece.color);\n}\nexport const canMove = (state, orig, dest) => orig !== dest && isMovable(state, orig) && (state.movable.free || !!state.movable.dests?.get(orig)?.includes(dest));\nfunction canDrop(state, orig, dest) {\n  const piece = state.pieces.get(orig);\n  return !!piece && (orig === dest || !state.pieces.has(dest)) && (state.movable.color === 'both' || state.movable.color === piece.color && state.turnColor === piece.color);\n}\nfunction isPremovable(state, orig) {\n  const piece = state.pieces.get(orig);\n  return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nconst canPremove = (state, orig, dest) => orig !== dest && isPremovable(state, orig) && (state.premovable.customDests?.get(orig) ?? premove(state, orig)).includes(dest);\nfunction canPredrop(state, orig, dest) {\n  const piece = state.pieces.get(orig);\n  const destPiece = state.pieces.get(dest);\n  return !!piece && (!destPiece || destPiece.color !== state.movable.color) && state.predroppable.enabled && (piece.role !== 'pawn' || dest[1] !== '1' && dest[1] !== '8') && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nexport function isDraggable(state, orig) {\n  const piece = state.pieces.get(orig);\n  return !!piece && state.draggable.enabled && (state.movable.color === 'both' || state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled));\n}\nexport function playPremove(state) {\n  const move = state.premovable.current;\n  if (!move) return false;\n  const orig = move[0],\n    dest = move[1];\n  let success = false;\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const metadata = {\n        premove: true\n      };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      success = true;\n    }\n  }\n  unsetPremove(state);\n  return success;\n}\nexport function playPredrop(state, validate) {\n  const drop = state.predroppable.current;\n  let success = false;\n  if (!drop) return false;\n  if (validate(drop)) {\n    const piece = {\n      role: drop.role,\n      color: state.movable.color\n    };\n    if (baseNewPiece(state, piece, drop.key)) {\n      callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n        premove: false,\n        predrop: true\n      });\n      success = true;\n    }\n  }\n  unsetPredrop(state);\n  return success;\n}\nexport function cancelMove(state) {\n  unsetPremove(state);\n  unsetPredrop(state);\n  unselect(state);\n}\nexport function stop(state) {\n  state.movable.color = state.movable.dests = state.animation.current = undefined;\n  cancelMove(state);\n}\nexport function getKeyAtDomPos(pos, asWhite, bounds) {\n  let file = Math.floor(8 * (pos[0] - bounds.left) / bounds.width);\n  if (!asWhite) file = 7 - file;\n  let rank = 7 - Math.floor(8 * (pos[1] - bounds.top) / bounds.height);\n  if (!asWhite) rank = 7 - rank;\n  return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : undefined;\n}\nexport function getSnappedKeyAtDomPos(orig, pos, asWhite, bounds) {\n  const origPos = key2pos(orig);\n  const validSnapPos = allPos.filter(pos2 => samePos(origPos, pos2) || queenDir(origPos[0], origPos[1], pos2[0], pos2[1]) || knightDir(origPos[0], origPos[1], pos2[0], pos2[1]));\n  const validSnapCenters = validSnapPos.map(pos2 => computeSquareCenter(pos2keyUnsafe(pos2), asWhite, bounds));\n  const validSnapDistances = validSnapCenters.map(pos2 => distanceSq(pos, pos2));\n  const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index) => a[0] < b ? a : [b, index], [validSnapDistances[0], 0]);\n  return pos2key(validSnapPos[closestSnapIndex]);\n}\nexport const whitePov = s => s.orientation === 'white';\n//# sourceMappingURL=board.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}