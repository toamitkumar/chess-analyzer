{"ast":null,"code":"var __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nimport { Component, Input, Output, EventEmitter, ViewChild } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Chess } from 'chess.js';\nimport { Chessground } from '@lichess-org/chessground';\nimport { MoveQuality, MOVE_QUALITY_COLORS } from '../../constants/move-quality.constants';\nlet ChessBoardComponent = (() => {\n  let _classDecorators = [Component({\n    selector: 'app-chess-board',\n    standalone: true,\n    imports: [CommonModule, WinProbabilityComponent],\n    template: `\n    <div class=\"chess-board-container\">\n      <div class=\"board-and-evaluation\">\n        <div class=\"chess-board-wrapper\" [class.flipped]=\"isFlipped\">\n          <!-- Player names -->\n          <div *ngIf=\"whitePlayer\" [class]=\"getPlayerNameClass('white')\">\n            <div class=\"flex items-center gap-2\">\n              <div class=\"w-3 h-3 bg-white border border-gray-400 rounded-sm\"></div>\n              <span>{{ whitePlayer }}</span>\n            </div>\n          </div>\n          \n          <div *ngIf=\"blackPlayer\" [class]=\"getPlayerNameClass('black')\">\n            <div class=\"flex items-center gap-2\">\n              <div class=\"w-3 h-3 bg-gray-800 border border-gray-600 rounded-sm\"></div>\n              <span>{{ blackPlayer }}</span>\n            </div>\n          </div>\n\n          <div class=\"board-with-eval\">\n            <div #chessBoard class=\"chess-board\"></div>\n          </div>\n        </div>\n      </div>\n      \n      <div class=\"board-controls\">\n        <button \n          (click)=\"goToStart()\" \n          [disabled]=\"currentMoveIndex === 0\"\n          class=\"control-btn\">\n          <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M11 19l-7-7 7-7m8 14l-7-7 7-7\"/>\n          </svg>\n        </button>\n        \n        <button \n          (click)=\"previousMove()\" \n          [disabled]=\"currentMoveIndex === 0\"\n          class=\"control-btn\">\n          <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 19l-7-7 7-7\"/>\n          </svg>\n        </button>\n\n        <button \n          (click)=\"flipBoard()\" \n          class=\"control-btn flip-btn\"\n          title=\"Flip Board\">\n          <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4\"/>\n          </svg>\n        </button>\n        \n        <button \n          (click)=\"nextMove()\" \n          [disabled]=\"currentMoveIndex >= moves.length - 1\"\n          class=\"control-btn\">\n          <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 5l7 7-7 7\"/>\n          </svg>\n        </button>\n        \n        <button \n          (click)=\"goToEnd()\" \n          [disabled]=\"currentMoveIndex >= moves.length - 1\"\n          class=\"control-btn\">\n          <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 5l7 7-7 7M5 5l7 7-7 7\"/>\n          </svg>\n        </button>\n      </div>\n      \n      <div class=\"position-info\">\n        <div class=\"move-info\">\n          <span class=\"move-number\">Move {{ Math.ceil((currentMoveIndex + 1) / 2) }}</span>\n          <span class=\"move-notation\" *ngIf=\"currentMove\">{{ currentMove.move }}</span>\n        </div>\n        <div class=\"evaluation\" *ngIf=\"currentMove\">\n          <span [class]=\"getEvaluationClass()\">{{ formatEvaluation(currentMove.evaluation) }}</span>\n          <span class=\"move-quality\" [class]=\"getMoveQualityClass()\">{{ getMoveQuality() }}</span>\n        </div>\n      </div>\n    </div>\n  `,\n    styles: [`\n    .chess-board-container {\n      @apply flex flex-col items-center gap-4 p-4;\n      max-width: 100%;\n    }\n\n    .board-and-evaluation {\n      @apply flex items-start gap-1;\n    }\n\n    .chess-board-wrapper {\n      @apply relative;\n      width: clamp(360px, 60vw, 520px);\n      height: clamp(360px, 60vw, 520px);\n      aspect-ratio: 1;\n    }\n\n    .board-with-eval {\n      @apply flex items-start gap-1;\n      width: 100%;\n      height: 100%;\n    }\n\n    .chess-board {\n      width: 100%;\n      height: 100%;\n      min-width: 320px;\n      min-height: 320px;\n      background: #f0d9b5;\n    }\n\n    /* Force Chessground visibility */\n    :host ::ng-deep cg-board {\n      width: 100% !important;\n      height: 100% !important;\n      display: block !important;\n    }\n\n    :host ::ng-deep cg-container {\n      width: 100% !important;\n      height: 100% !important;\n      display: block !important;\n    }\n\n    :host ::ng-deep .cg-wrap {\n      width: 100% !important;\n      height: 100% !important;\n      display: block !important;\n    }\n\n    /* Evaluation section positioned on the side */\n    .evaluation-section {\n      @apply flex;\n      height: 100%;\n    }\n\n    /* Player name styling */\n    .player-name {\n      @apply absolute z-20 px-3 py-2 rounded-md font-semibold text-sm;\n      @apply bg-white/90 backdrop-blur-sm border border-gray-200 shadow-md;\n      @apply transition-all duration-200;\n      min-width: 120px;\n      text-align: center;\n    }\n\n    .player-name:hover {\n      @apply bg-white shadow-lg scale-105;\n    }\n\n    .player-name.bottom-left {\n      bottom: -40px;\n      left: 0px;\n    }\n\n    .player-name.top-left {\n      top: -40px;\n      left: 0px;\n    }\n\n    .player-name.player-white {\n      @apply text-gray-800 border-gray-300;\n      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);\n    }\n\n    .player-name.player-black {\n      @apply text-white border-gray-600;\n      background: linear-gradient(135deg, #343a40 0%, #212529 100%);\n    }\n\n    /* Board controls */\n    .board-controls {\n      @apply flex items-center justify-center gap-2 mt-4;\n      @apply bg-white rounded-lg p-2 shadow-sm border border-gray-200;\n    }\n\n    .control-btn {\n      @apply flex items-center justify-center w-10 h-10 rounded-md;\n      @apply bg-gray-100 hover:bg-gray-200 text-gray-700;\n      @apply transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500;\n    }\n\n    .control-btn:hover {\n      @apply shadow-md transform scale-105;\n    }\n\n    .control-btn:disabled {\n      @apply opacity-50 cursor-not-allowed;\n    }\n\n    .flip-btn {\n      @apply bg-blue-100 hover:bg-blue-200 text-blue-700;\n    }\n\n    /* Evaluation section */\n    .evaluation-section {\n      @apply flex justify-center mt-4;\n    }\n\n    /* Responsive design */\n    @media (max-width: 640px) {\n      .chess-board-container {\n        @apply p-2 gap-2;\n      }\n\n      .board-and-evaluation {\n        @apply flex-col gap-2;\n      }\n      \n      .chess-board-wrapper {\n        width: calc(100vw - 32px);\n        height: calc(100vw - 32px);\n        max-width: 360px;\n        max-height: 360px;\n      }\n\n      .evaluation-section {\n        height: auto;\n      }\n      \n      .player-name {\n        @apply px-2 py-1 text-xs;\n        min-width: 100px;\n      }\n      \n      .control-btn {\n        @apply w-8 h-8;\n      }\n    }\n  `]\n  })];\n  let _classDescriptor;\n  let _classExtraInitializers = [];\n  let _classThis;\n  let _instanceExtraInitializers = [];\n  let _chessBoardElement_decorators;\n  let _chessBoardElement_initializers = [];\n  let _moves_decorators;\n  let _moves_initializers = [];\n  let _initialPosition_decorators;\n  let _initialPosition_initializers = [];\n  let _whitePlayer_decorators;\n  let _whitePlayer_initializers = [];\n  let _blackPlayer_decorators;\n  let _blackPlayer_initializers = [];\n  let _moveChanged_decorators;\n  let _moveChanged_initializers = [];\n  var ChessBoardComponent = class {\n    static {\n      _classThis = this;\n    }\n    constructor() {\n      this.chessBoardElement = (__runInitializers(this, _instanceExtraInitializers), __runInitializers(this, _chessBoardElement_initializers, void 0));\n      this.moves = __runInitializers(this, _moves_initializers, []);\n      this.initialPosition = __runInitializers(this, _initialPosition_initializers, 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');\n      this.whitePlayer = __runInitializers(this, _whitePlayer_initializers, '');\n      this.blackPlayer = __runInitializers(this, _blackPlayer_initializers, '');\n      this.moveChanged = __runInitializers(this, _moveChanged_initializers, new EventEmitter());\n      this.board = null;\n      this.currentMoveIndex = -1;\n      this.currentMove = null;\n      this.isFlipped = false;\n      // Make Math available in template\n      this.Math = Math;\n      this.handleKeyPress = event => {\n        switch (event.key) {\n          case 'ArrowLeft':\n            event.preventDefault();\n            this.previousMove();\n            break;\n          case 'ArrowRight':\n            event.preventDefault();\n            this.nextMove();\n            break;\n          case 'Home':\n            event.preventDefault();\n            this.goToStart();\n            break;\n          case 'End':\n            event.preventDefault();\n            this.goToEnd();\n            break;\n        }\n      };\n    }\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n      _chessBoardElement_decorators = [ViewChild('chessBoard', {\n        static: true\n      })];\n      _moves_decorators = [Input()];\n      _initialPosition_decorators = [Input()];\n      _whitePlayer_decorators = [Input()];\n      _blackPlayer_decorators = [Input()];\n      _moveChanged_decorators = [Output()];\n      __esDecorate(null, null, _chessBoardElement_decorators, {\n        kind: \"field\",\n        name: \"chessBoardElement\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"chessBoardElement\" in obj,\n          get: obj => obj.chessBoardElement,\n          set: (obj, value) => {\n            obj.chessBoardElement = value;\n          }\n        },\n        metadata: _metadata\n      }, _chessBoardElement_initializers, _instanceExtraInitializers);\n      __esDecorate(null, null, _moves_decorators, {\n        kind: \"field\",\n        name: \"moves\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"moves\" in obj,\n          get: obj => obj.moves,\n          set: (obj, value) => {\n            obj.moves = value;\n          }\n        },\n        metadata: _metadata\n      }, _moves_initializers, _instanceExtraInitializers);\n      __esDecorate(null, null, _initialPosition_decorators, {\n        kind: \"field\",\n        name: \"initialPosition\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"initialPosition\" in obj,\n          get: obj => obj.initialPosition,\n          set: (obj, value) => {\n            obj.initialPosition = value;\n          }\n        },\n        metadata: _metadata\n      }, _initialPosition_initializers, _instanceExtraInitializers);\n      __esDecorate(null, null, _whitePlayer_decorators, {\n        kind: \"field\",\n        name: \"whitePlayer\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"whitePlayer\" in obj,\n          get: obj => obj.whitePlayer,\n          set: (obj, value) => {\n            obj.whitePlayer = value;\n          }\n        },\n        metadata: _metadata\n      }, _whitePlayer_initializers, _instanceExtraInitializers);\n      __esDecorate(null, null, _blackPlayer_decorators, {\n        kind: \"field\",\n        name: \"blackPlayer\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"blackPlayer\" in obj,\n          get: obj => obj.blackPlayer,\n          set: (obj, value) => {\n            obj.blackPlayer = value;\n          }\n        },\n        metadata: _metadata\n      }, _blackPlayer_initializers, _instanceExtraInitializers);\n      __esDecorate(null, null, _moveChanged_decorators, {\n        kind: \"field\",\n        name: \"moveChanged\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"moveChanged\" in obj,\n          get: obj => obj.moveChanged,\n          set: (obj, value) => {\n            obj.moveChanged = value;\n          }\n        },\n        metadata: _metadata\n      }, _moveChanged_initializers, _instanceExtraInitializers);\n      __esDecorate(null, _classDescriptor = {\n        value: _classThis\n      }, _classDecorators, {\n        kind: \"class\",\n        name: _classThis.name,\n        metadata: _metadata\n      }, null, _classExtraInitializers);\n      ChessBoardComponent = _classThis = _classDescriptor.value;\n      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n      __runInitializers(_classThis, _classExtraInitializers);\n    }\n    ngOnInit() {\n      console.log('ChessBoardComponent ngOnInit called');\n      this.game = new Chess(this.initialPosition);\n      this.setupKeyboardListeners();\n    }\n    ngOnChanges(changes) {\n      if (changes['moves'] && this.moves) {\n        // Reset to initial position when moves change\n        this.currentMoveIndex = -1;\n        this.currentMove = null;\n        if (this.game) {\n          this.game.reset();\n          this.game.load(this.initialPosition);\n        }\n      }\n    }\n    ngAfterViewInit() {\n      console.log('Chess board component initializing...');\n      setTimeout(() => {\n        this.initializeBoard();\n      }, 100);\n    }\n    initializeBoard() {\n      console.log('Initializing Chessground board...');\n      const element = this.chessBoardElement?.nativeElement;\n      if (!element) {\n        console.error('Chess board element not found');\n        return;\n      }\n      console.log('Board element:', element);\n      try {\n        const config = {\n          fen: this.initialPosition,\n          orientation: this.isFlipped ? 'black' : 'white',\n          viewOnly: true,\n          coordinates: true,\n          highlight: {\n            lastMove: true,\n            check: true\n          },\n          animation: {\n            enabled: true,\n            duration: 200\n          },\n          drawable: {\n            enabled: false\n          }\n        };\n        console.log('Creating Chessground with config:', config);\n        this.board = Chessground(element, config);\n        console.log('Chessground board created successfully');\n        // Force a redraw and set position\n        if (this.board) {\n          this.board.set({\n            fen: this.initialPosition\n          });\n          this.board.redrawAll();\n        }\n      } catch (error) {\n        console.error('Failed to initialize Chessground:', error);\n      }\n    }\n    ngOnDestroy() {\n      this.removeKeyboardListeners();\n      if (this.board) {\n        this.board.destroy();\n      }\n    }\n    setupKeyboardListeners() {\n      document.addEventListener('keydown', this.handleKeyPress);\n    }\n    removeKeyboardListeners() {\n      document.removeEventListener('keydown', this.handleKeyPress);\n    }\n    goToStart() {\n      this.goToMove(-1);\n    }\n    previousMove() {\n      if (this.currentMoveIndex > -1) {\n        this.goToMove(this.currentMoveIndex - 1);\n      }\n    }\n    nextMove() {\n      if (this.currentMoveIndex < this.moves.length - 1) {\n        this.goToMove(this.currentMoveIndex + 1);\n      }\n    }\n    goToEnd() {\n      this.goToMove(this.moves.length - 1);\n    }\n    goToMove(moveIndex) {\n      this.currentMoveIndex = moveIndex;\n      this.currentMove = moveIndex >= 0 ? this.moves[moveIndex] : null;\n      // Reset game to initial position\n      this.game = new Chess(this.initialPosition);\n      // Play moves up to current position\n      let lastMove;\n      for (let i = 0; i <= moveIndex; i++) {\n        if (this.moves[i]) {\n          try {\n            const move = this.game.move(this.moves[i].move);\n            if (i === moveIndex) {\n              lastMove = {\n                from: move.from,\n                to: move.to\n              };\n            }\n          } catch (error) {\n            console.error('Invalid move:', this.moves[i].move, error);\n            break;\n          }\n        }\n      }\n      // Update board position\n      if (this.board) {\n        this.board.set({\n          fen: this.game.fen(),\n          lastMove: lastMove ? [lastMove.from, lastMove.to] : undefined\n        });\n      }\n      // Emit move change event\n      this.moveChanged.emit(moveIndex);\n    }\n    formatEvaluation(evaluation) {\n      if (Math.abs(evaluation) > 900) {\n        return evaluation > 0 ? '+M' : '-M';\n      }\n      return (evaluation / 100).toFixed(1);\n    }\n    getEvaluationClass() {\n      if (!this.currentMove) return 'eval-neutral';\n      const evaluation = this.currentMove.evaluation;\n      if (evaluation > 50) return 'eval-positive';\n      if (evaluation < -50) return 'eval-negative';\n      return 'eval-neutral';\n    }\n    getMoveQuality() {\n      if (!this.currentMove) return '';\n      // Check for book moves (first 10 moves typically)\n      if (this.currentMoveIndex < 10) return MoveQuality.BOOK;\n      // Check for best moves (low centipawn loss)\n      if (this.currentMove.centipawn_loss <= 5) return MoveQuality.BEST;\n      if (this.currentMove.is_blunder) return MoveQuality.BLUNDER;\n      if (this.currentMove.is_mistake) return MoveQuality.MISTAKE;\n      if (this.currentMove.is_inaccuracy) return MoveQuality.INACCURACY;\n      if (this.currentMove.centipawn_loss <= 10) return MoveQuality.EXCELLENT;\n      return MoveQuality.GOOD;\n    }\n    getMoveQualityStyle() {\n      const quality = this.getMoveQuality();\n      const colors = MOVE_QUALITY_COLORS[quality];\n      if (!colors) return {};\n      return {\n        'background-color': colors.background,\n        'color': colors.text,\n        'border-color': colors.border\n      };\n    }\n    getMoveQualityClass() {\n      const quality = this.getMoveQuality().toLowerCase();\n      return `move-${quality}`;\n    }\n    flipBoard() {\n      this.isFlipped = !this.isFlipped;\n      if (this.board) {\n        this.board.set({\n          orientation: this.isFlipped ? 'black' : 'white'\n        });\n      }\n    }\n    getPlayerNameClass(player) {\n      const baseClass = 'player-name';\n      const colorClass = `player-${player}`;\n      let positionClass;\n      if (player === 'white') {\n        positionClass = this.isFlipped ? 'top-left' : 'bottom-left';\n      } else {\n        positionClass = this.isFlipped ? 'bottom-left' : 'top-left';\n      }\n      return `${baseClass} ${colorClass} ${positionClass}`;\n    }\n    getBoardHeight() {\n      const viewportWidth = window.innerWidth;\n      if (viewportWidth < 640) return Math.min(400, viewportWidth - 32);\n      if (viewportWidth < 1024) return Math.min(520, viewportWidth * 0.6);\n      return 520;\n    }\n  };\n  return ChessBoardComponent = _classThis;\n})();\nexport { ChessBoardComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}