{"ast":null,"code":"import * as util from './util.js';\nconst isDestOccupiedByFriendly = ctx => ctx.friendlies.has(ctx.dest.key);\nconst isDestOccupiedByEnemy = ctx => ctx.enemies.has(ctx.dest.key);\nconst anyPieceBetween = (orig, dest, pieces) => util.squaresBetween(...orig, ...dest).some(s => pieces.has(s));\nconst canEnemyPawnAdvanceToSquare = (pawnStart, dest, ctx) => {\n  const piece = ctx.enemies.get(pawnStart);\n  if (piece?.role !== 'pawn') return false;\n  const step = piece.color === 'white' ? 1 : -1;\n  const startPos = util.key2pos(pawnStart);\n  const destPos = util.key2pos(dest);\n  return util.pawnDirAdvance(...startPos, ...destPos, piece.color === 'white') && !anyPieceBetween(startPos, [destPos[0], destPos[1] + step], ctx.allPieces);\n};\nconst canEnemyPawnCaptureOnSquare = (pawnStart, dest, ctx) => {\n  const enemyPawn = ctx.enemies.get(pawnStart);\n  return enemyPawn?.role === 'pawn' && util.pawnDirCapture(...util.key2pos(pawnStart), ...util.key2pos(dest), enemyPawn.color === 'white') && (ctx.friendlies.has(dest) || canBeCapturedBySomeEnemyEnPassant(util.squareShiftedVertically(dest, enemyPawn.color === 'white' ? -1 : 1), ctx.friendlies, ctx.enemies, ctx.lastMove));\n};\nconst canSomeEnemyPawnAdvanceToDest = ctx => [...ctx.enemies.keys()].some(key => canEnemyPawnAdvanceToSquare(key, ctx.dest.key, ctx));\nconst isDestControlledByEnemy = (ctx, pieceRolesExclude) => {\n  const square = ctx.dest.pos;\n  return [...ctx.enemies].some(([key, piece]) => {\n    const piecePos = util.key2pos(key);\n    return !pieceRolesExclude?.includes(piece.role) && (piece.role === 'pawn' && util.pawnDirCapture(...piecePos, ...square, piece.color === 'white') || piece.role === 'knight' && util.knightDir(...piecePos, ...square) || piece.role === 'bishop' && util.bishopDir(...piecePos, ...square) || piece.role === 'rook' && util.rookDir(...piecePos, ...square) || piece.role === 'queen' && util.queenDir(...piecePos, ...square) || piece.role === 'king' && util.kingDirNonCastling(...piecePos, ...square)) && (!['bishop', 'rook', 'queen'].includes(piece.role) || !anyPieceBetween(piecePos, square, ctx.allPieces));\n  });\n};\nconst isFriendlyOnDestAndAttacked = ctx => isDestOccupiedByFriendly(ctx) && (canBeCapturedBySomeEnemyEnPassant(ctx.dest.key, ctx.friendlies, ctx.enemies, ctx.lastMove) || isDestControlledByEnemy(ctx));\nconst canBeCapturedBySomeEnemyEnPassant = (potentialSquareOfFriendlyPawn, friendlies, enemies, lastMove) => {\n  if (!potentialSquareOfFriendlyPawn || lastMove && potentialSquareOfFriendlyPawn !== lastMove[1]) return false;\n  const pos = util.key2pos(potentialSquareOfFriendlyPawn);\n  const friendly = friendlies.get(potentialSquareOfFriendlyPawn);\n  return friendly?.role === 'pawn' && pos[1] === (friendly.color === 'white' ? 3 : 4) && (!lastMove || util.diff(util.key2pos(lastMove[0])[1], pos[1]) === 2) && [1, -1].some(delta => {\n    const k = util.pos2key([pos[0] + delta, pos[1]]);\n    return !!k && enemies.get(k)?.role === 'pawn';\n  });\n};\nconst isPathClearEnoughOfFriendliesForPremove = (ctx, isPawnAdvance) => {\n  if (ctx.unrestrictedPremoves) return true;\n  const squaresBetween = util.squaresBetween(...ctx.orig.pos, ...ctx.dest.pos);\n  if (isPawnAdvance) squaresBetween.push(ctx.dest.key);\n  const squaresOfFriendliesBetween = squaresBetween.filter(s => ctx.friendlies.has(s));\n  if (!squaresOfFriendliesBetween.length) return true;\n  const firstSquareOfFriendliesBetween = squaresOfFriendliesBetween[0];\n  const nextSquare = util.squareShiftedVertically(firstSquareOfFriendliesBetween, ctx.color === 'white' ? -1 : 1);\n  return squaresOfFriendliesBetween.length === 1 && canBeCapturedBySomeEnemyEnPassant(firstSquareOfFriendliesBetween, ctx.friendlies, ctx.enemies, ctx.lastMove) && !!nextSquare && !squaresBetween.includes(nextSquare);\n};\nconst isPathClearEnoughOfEnemiesForPremove = (ctx, isPawnAdvance) => {\n  if (ctx.unrestrictedPremoves) return true;\n  const squaresBetween = util.squaresBetween(...ctx.orig.pos, ...ctx.dest.pos);\n  if (isPawnAdvance) squaresBetween.push(ctx.dest.key);\n  const squaresOfEnemiesBetween = squaresBetween.filter(s => ctx.enemies.has(s));\n  if (squaresOfEnemiesBetween.length > 1) return false;\n  if (!squaresOfEnemiesBetween.length) return true;\n  const enemySquare = squaresOfEnemiesBetween[0];\n  const enemy = ctx.enemies.get(enemySquare);\n  if (!enemy || enemy.role !== 'pawn') return true;\n  const enemyStep = enemy.color === 'white' ? 1 : -1;\n  const squareAbove = util.squareShiftedVertically(enemySquare, enemyStep);\n  const enemyPawnDests = squareAbove ? [...util.adjacentSquares(squareAbove).filter(s => canEnemyPawnCaptureOnSquare(enemySquare, s, ctx)), ...[squareAbove, util.squareShiftedVertically(squareAbove, enemyStep)].filter(s => !!s).filter(s => canEnemyPawnAdvanceToSquare(enemySquare, s, ctx))] : [];\n  const badSquares = [...squaresBetween, ctx.orig.key];\n  return enemyPawnDests.some(square => !badSquares.includes(square));\n};\nconst isPathClearEnoughForPremove = (ctx, isPawnAdvance) => isPathClearEnoughOfFriendliesForPremove(ctx, isPawnAdvance) && isPathClearEnoughOfEnemiesForPremove(ctx, isPawnAdvance);\nconst pawn = ctx => {\n  const step = ctx.color === 'white' ? 1 : -1;\n  if (util.diff(ctx.orig.pos[0], ctx.dest.pos[0]) > 1) return false;\n  if (!util.diff(ctx.orig.pos[0], ctx.dest.pos[0])) return util.pawnDirAdvance(...ctx.orig.pos, ...ctx.dest.pos, ctx.color === 'white') && isPathClearEnoughForPremove(ctx, true);\n  if (ctx.dest.pos[1] !== ctx.orig.pos[1] + step) return false;\n  if (ctx.unrestrictedPremoves || isDestOccupiedByEnemy(ctx)) return true;\n  if (isDestOccupiedByFriendly(ctx)) return isDestControlledByEnemy(ctx);else return canSomeEnemyPawnAdvanceToDest(ctx) || canBeCapturedBySomeEnemyEnPassant(util.pos2key([ctx.dest.pos[0], ctx.dest.pos[1] + step]), ctx.friendlies, ctx.enemies, ctx.lastMove) || isDestControlledByEnemy(ctx, ['pawn']);\n};\nconst knight = ctx => util.knightDir(...ctx.orig.pos, ...ctx.dest.pos) && (ctx.unrestrictedPremoves || !isDestOccupiedByFriendly(ctx) || isFriendlyOnDestAndAttacked(ctx));\nconst bishop = ctx => util.bishopDir(...ctx.orig.pos, ...ctx.dest.pos) && isPathClearEnoughForPremove(ctx, false) && (ctx.unrestrictedPremoves || !isDestOccupiedByFriendly(ctx) || isFriendlyOnDestAndAttacked(ctx));\nconst rook = ctx => util.rookDir(...ctx.orig.pos, ...ctx.dest.pos) && isPathClearEnoughForPremove(ctx, false) && (ctx.unrestrictedPremoves || !isDestOccupiedByFriendly(ctx) || isFriendlyOnDestAndAttacked(ctx));\nconst queen = ctx => bishop(ctx) || rook(ctx);\nconst king = ctx => util.kingDirNonCastling(...ctx.orig.pos, ...ctx.dest.pos) && (ctx.unrestrictedPremoves || !isDestOccupiedByFriendly(ctx) || isFriendlyOnDestAndAttacked(ctx)) || ctx.canCastle && ctx.orig.pos[1] === ctx.dest.pos[1] && ctx.orig.pos[1] === (ctx.color === 'white' ? 0 : 7) && (ctx.orig.pos[0] === 4 && (ctx.dest.pos[0] === 2 && ctx.rookFilesFriendlies.includes(0) || ctx.dest.pos[0] === 6 && ctx.rookFilesFriendlies.includes(7)) || ctx.rookFilesFriendlies.includes(ctx.dest.pos[0])) && (ctx.unrestrictedPremoves ||\n/* The following checks if no non-rook friendly piece is in the way between the king and its castling destination.\n   Note that for the Chess960 edge case of Kb1 \"long castling\", the check passes even if there is a piece in the way\n   on c1. But this is fine, since premoving from b1 to a1 as a normal move would have already returned true. */\nutil.squaresBetween(...ctx.orig.pos, ctx.dest.pos[0] > ctx.orig.pos[0] ? 7 : 1, ctx.dest.pos[1]).map(s => ctx.allPieces.get(s)).every(p => !p || util.samePiece(p, {\n  role: 'rook',\n  color: ctx.color\n})));\nconst mobilityByRole = {\n  pawn,\n  knight,\n  bishop,\n  rook,\n  queen,\n  king\n};\nexport function premove(state, key) {\n  const pieces = state.pieces,\n    canCastle = state.premovable.castle,\n    unrestrictedPremoves = !!state.premovable.unrestrictedPremoves;\n  const piece = pieces.get(key);\n  if (!piece || piece.color === state.turnColor) return [];\n  const color = piece.color,\n    friendlies = new Map([...pieces].filter(([_, p]) => p.color === color)),\n    enemies = new Map([...pieces].filter(([_, p]) => p.color === util.opposite(color))),\n    orig = {\n      key,\n      pos: util.key2pos(key)\n    },\n    mobility = ctx => mobilityByRole[piece.role](ctx) && state.premovable.additionalPremoveRequirements(ctx),\n    partialCtx = {\n      orig,\n      role: piece.role,\n      allPieces: pieces,\n      friendlies: friendlies,\n      enemies: enemies,\n      unrestrictedPremoves: unrestrictedPremoves,\n      color: color,\n      canCastle: canCastle,\n      rookFilesFriendlies: Array.from(pieces).filter(([k, p]) => k[1] === (color === 'white' ? '1' : '8') && p.color === color && p.role === 'rook').map(([k]) => util.key2pos(k)[0]),\n      lastMove: state.lastMove\n    };\n  return util.allPosAndKey.filter(dest => mobility({\n    ...partialCtx,\n    dest\n  })).map(pk => pk.key);\n}\n//# sourceMappingURL=premove.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}