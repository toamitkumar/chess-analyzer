{"ast":null,"code":"import _asyncToGenerator from \"/Users/amit.kumar3/projects/chess-analysis/chessify/newfrontend/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nimport { ChessboardState } from \"./model/ChessboardState.js\";\nimport { FEN, Position } from \"./model/Position.js\";\nimport { PositionAnimationsQueue } from \"./view/PositionAnimationsQueue.js\";\nimport { EXTENSION_POINT } from \"./model/Extension.js\";\nimport { ChessboardView, COLOR, INPUT_EVENT_TYPE, BORDER_TYPE, POINTER_EVENTS } from \"./view/ChessboardView.js\";\nimport { Utils } from \"./lib/Utils.js\";\nexport const PIECE = {\n  wp: \"wp\",\n  wb: \"wb\",\n  wn: \"wn\",\n  wr: \"wr\",\n  wq: \"wq\",\n  wk: \"wk\",\n  bp: \"bp\",\n  bb: \"bb\",\n  bn: \"bn\",\n  br: \"br\",\n  bq: \"bq\",\n  bk: \"bk\"\n};\nexport const PIECE_TYPE = {\n  pawn: \"p\",\n  knight: \"n\",\n  bishop: \"b\",\n  rook: \"r\",\n  queen: \"q\",\n  king: \"k\"\n};\nexport const PIECES_FILE_TYPE = {\n  svgSprite: \"svgSprite\"\n};\nexport { COLOR };\nexport { INPUT_EVENT_TYPE };\nexport { POINTER_EVENTS };\nexport { BORDER_TYPE };\nexport { FEN };\nexport class Chessboard {\n  constructor(context, props = {}) {\n    if (!context) {\n      throw new Error(\"container element is \" + context);\n    }\n    this.context = context;\n    this.id = (Math.random() + 1).toString(36).substring(2, 8);\n    this.extensions = [];\n    this.props = {\n      position: FEN.empty,\n      // set position as fen, use FEN.start or FEN.empty as shortcuts\n      orientation: COLOR.white,\n      // white on bottom\n      responsive: true,\n      // resize the board automatically to the size of the context element\n      assetsUrl: \"./assets/\",\n      // put all css and sprites in this folder, will be ignored for absolute urls of assets files\n      assetsCache: true,\n      // cache the sprites, deactivate if you want to use multiple pieces sets in one page\n      style: {\n        cssClass: \"default\",\n        // set the css theme of the board, try \"green\", \"blue\" or \"chess-club\"\n        showCoordinates: true,\n        // show ranks and files\n        borderType: BORDER_TYPE.none,\n        // \"thin\" thin border, \"frame\" wide border with coordinates in it, \"none\" no border\n        aspectRatio: 1,\n        // height/width of the board\n        pieces: {\n          type: PIECES_FILE_TYPE.svgSprite,\n          // pieces are in an SVG sprite, no other type supported for now\n          file: \"pieces/standard.svg\",\n          // the filename of the sprite in `assets/pieces/` or an absolute url like `https://…` or `/…`\n          tileSize: 40 // the tile size in the sprite\n        },\n        animationDuration: 300 // pieces animation duration in milliseconds. Disable all animations with `0`\n      },\n      extensions: [/* {class: ExtensionClass, props: { ... }} */] // add extensions here\n    };\n    Utils.mergeObjects(this.props, props);\n    this.state = new ChessboardState();\n    this.view = new ChessboardView(this);\n    this.positionAnimationsQueue = new PositionAnimationsQueue(this);\n    this.state.orientation = this.props.orientation;\n    // instantiate extensions\n    for (const extensionData of this.props.extensions) {\n      this.addExtension(extensionData.class, extensionData.props);\n    }\n    this.view.redrawBoard();\n    this.state.position = new Position(this.props.position);\n    this.view.redrawPieces();\n    this.state.invokeExtensionPoints(EXTENSION_POINT.positionChanged);\n    this.initialized = Promise.resolve(); // deprecated 2023-09-19 don't use this anymore\n  }\n\n  // API //\n\n  setPiece(_x, _x2) {\n    var _this = this;\n    return _asyncToGenerator(function* (square, piece, animated = false) {\n      const positionFrom = _this.state.position.clone();\n      _this.state.position.setPiece(square, piece);\n      _this.state.invokeExtensionPoints(EXTENSION_POINT.positionChanged);\n      return _this.positionAnimationsQueue.enqueuePositionChange(positionFrom, _this.state.position.clone(), animated);\n    }).apply(this, arguments);\n  }\n  movePiece(_x3, _x4) {\n    var _this2 = this;\n    return _asyncToGenerator(function* (squareFrom, squareTo, animated = false) {\n      const positionFrom = _this2.state.position.clone();\n      _this2.state.position.movePiece(squareFrom, squareTo);\n      _this2.state.invokeExtensionPoints(EXTENSION_POINT.positionChanged);\n      return _this2.positionAnimationsQueue.enqueuePositionChange(positionFrom, _this2.state.position.clone(), animated);\n    }).apply(this, arguments);\n  }\n  setPosition(_x5) {\n    var _this3 = this;\n    return _asyncToGenerator(function* (fen, animated = false) {\n      const positionFrom = _this3.state.position.clone();\n      const positionTo = new Position(fen);\n      if (positionFrom.getFen() !== positionTo.getFen()) {\n        _this3.state.position.setFen(fen);\n        _this3.state.invokeExtensionPoints(EXTENSION_POINT.positionChanged);\n      }\n      return _this3.positionAnimationsQueue.enqueuePositionChange(positionFrom, _this3.state.position.clone(), animated);\n    }).apply(this, arguments);\n  }\n  setOrientation(_x6) {\n    var _this4 = this;\n    return _asyncToGenerator(function* (color, animated = false) {\n      const position = _this4.state.position.clone();\n      if (_this4.boardTurning) {\n        console.warn(\"setOrientation is only once in queue allowed\");\n        return;\n      }\n      _this4.boardTurning = true;\n      return _this4.positionAnimationsQueue.enqueueTurnBoard(position, color, animated).then(() => {\n        _this4.boardTurning = false;\n        _this4.state.invokeExtensionPoints(EXTENSION_POINT.boardChanged);\n      });\n    }).apply(this, arguments);\n  }\n  getPiece(square) {\n    return this.state.position.getPiece(square);\n  }\n  getPosition() {\n    return this.state.position.getFen();\n  }\n  getOrientation() {\n    return this.state.orientation;\n  }\n  enableMoveInput(eventHandler, color = undefined) {\n    this.view.enableMoveInput(eventHandler, color);\n  }\n  disableMoveInput() {\n    this.view.disableMoveInput();\n  }\n  isMoveInputEnabled() {\n    return this.state.inputWhiteEnabled || this.state.inputBlackEnabled;\n  }\n  enableSquareSelect(eventType = POINTER_EVENTS.pointerdown, eventHandler) {\n    if (!this.squareSelectListener) {\n      this.squareSelectListener = function (e) {\n        const square = e.target.getAttribute(\"data-square\");\n        eventHandler({\n          eventType: e.type,\n          event: e,\n          chessboard: this,\n          square: square\n        });\n      };\n    }\n    this.context.addEventListener(eventType, this.squareSelectListener);\n    this.state.squareSelectEnabled = true;\n    this.view.visualizeInputState();\n  }\n  disableSquareSelect(eventType) {\n    this.context.removeEventListener(eventType, this.squareSelectListener);\n    this.squareSelectListener = undefined;\n    this.state.squareSelectEnabled = false;\n    this.view.visualizeInputState();\n  }\n  isSquareSelectEnabled() {\n    return this.state.squareSelectEnabled;\n  }\n  addExtension(extensionClass, props) {\n    if (this.getExtension(extensionClass)) {\n      throw Error(\"extension \\\"\" + extensionClass.name + \"\\\" already added\");\n    }\n    this.extensions.push(new extensionClass(this, props));\n  }\n  getExtension(extensionClass) {\n    for (const extension of this.extensions) {\n      if (extension instanceof extensionClass) {\n        return extension;\n      }\n    }\n    return null;\n  }\n  destroy() {\n    this.state.invokeExtensionPoints(EXTENSION_POINT.destroy);\n    this.positionAnimationsQueue.destroy();\n    this.view.destroy();\n    this.view = undefined;\n    this.state = undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}