{"ast":null,"code":"import * as cg from './types.js';\nexport const invRanks = [...cg.ranks].reverse();\nexport const allKeys = cg.files.flatMap(f => cg.ranks.map(r => f + r));\nexport const pos2key = pos => pos.every(x => x >= 0 && x <= 7) ? allKeys[8 * pos[0] + pos[1]] : undefined;\nexport const pos2keyUnsafe = pos => pos2key(pos);\nexport const key2pos = k => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];\nexport const uciToMove = uci => {\n  if (!uci) return undefined;\n  if (uci[1] === '@') return [uci.slice(2, 4)];\n  return [uci.slice(0, 2), uci.slice(2, 4)];\n};\nexport const allPos = allKeys.map(key2pos);\nexport const allPosAndKey = allKeys.map((key, i) => ({\n  key,\n  pos: allPos[i]\n}));\nexport function memo(f) {\n  let v;\n  const ret = () => {\n    if (v === undefined) v = f();\n    return v;\n  };\n  ret.clear = () => {\n    v = undefined;\n  };\n  return ret;\n}\nexport const timer = () => {\n  let startAt;\n  return {\n    start() {\n      startAt = performance.now();\n    },\n    cancel() {\n      startAt = undefined;\n    },\n    stop() {\n      if (!startAt) return 0;\n      const time = performance.now() - startAt;\n      startAt = undefined;\n      return time;\n    }\n  };\n};\nexport const opposite = c => c === 'white' ? 'black' : 'white';\nexport const distanceSq = (pos1, pos2) => (pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2;\nexport const samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;\nexport const samePos = (p1, p2) => p1[0] === p2[0] && p1[1] === p2[1];\nexport const posToTranslate = bounds => (pos, asWhite) => [(asWhite ? pos[0] : 7 - pos[0]) * bounds.width / 8, (asWhite ? 7 - pos[1] : pos[1]) * bounds.height / 8];\nexport const translate = (el, pos) => {\n  el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\nexport const translateAndScale = (el, pos, scale = 1) => {\n  el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\nexport const setVisible = (el, v) => {\n  el.style.visibility = v ? 'visible' : 'hidden';\n};\nexport const eventPosition = e => {\n  if (e.clientX || e.clientX === 0) return [e.clientX, e.clientY];\n  if (e.targetTouches?.[0]) return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];\n  return; // touchend has no position!\n};\nexport const isRightButton = e => e.button === 2;\nexport const createEl = (tagName, className) => {\n  const el = document.createElement(tagName);\n  if (className) el.className = className;\n  return el;\n};\nexport function computeSquareCenter(key, asWhite, bounds) {\n  const pos = key2pos(key);\n  if (!asWhite) {\n    pos[0] = 7 - pos[0];\n    pos[1] = 7 - pos[1];\n  }\n  return [bounds.left + bounds.width * pos[0] / 8 + bounds.width / 16, bounds.top + bounds.height * (7 - pos[1]) / 8 + bounds.height / 16];\n}\nexport const diff = (a, b) => Math.abs(a - b);\nexport const knightDir = (x1, y1, x2, y2) => diff(x1, x2) * diff(y1, y2) === 2;\nexport const rookDir = (x1, y1, x2, y2) => x1 === x2 !== (y1 === y2);\nexport const bishopDir = (x1, y1, x2, y2) => diff(x1, x2) === diff(y1, y2) && x1 !== x2;\nexport const queenDir = (x1, y1, x2, y2) => rookDir(x1, y1, x2, y2) || bishopDir(x1, y1, x2, y2);\nexport const kingDirNonCastling = (x1, y1, x2, y2) => Math.max(diff(x1, x2), diff(y1, y2)) === 1;\nexport const pawnDirCapture = (x1, y1, x2, y2, isDirectionUp) => diff(x1, x2) === 1 && y2 === y1 + (isDirectionUp ? 1 : -1);\nexport const pawnDirAdvance = (x1, y1, x2, y2, isDirectionUp) => {\n  const step = isDirectionUp ? 1 : -1;\n  return x1 === x2 && (y2 === y1 + step ||\n  // allow 2 squares from first two ranks, for horde\n  y2 === y1 + 2 * step && (isDirectionUp ? y1 <= 1 : y1 >= 6));\n};\n/** Returns all board squares between (x1, y1) and (x2, y2) exclusive,\n *  along a straight line (rook or bishop path). Returns [] if not aligned, or none between.\n */\nexport const squaresBetween = (x1, y1, x2, y2) => {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  // Must be a straight or diagonal line\n  if (dx && dy && Math.abs(dx) !== Math.abs(dy)) return [];\n  const stepX = Math.sign(dx),\n    stepY = Math.sign(dy);\n  const squares = [];\n  let x = x1 + stepX,\n    y = y1 + stepY;\n  while (x !== x2 || y !== y2) {\n    squares.push([x, y]);\n    x += stepX;\n    y += stepY;\n  }\n  return squares.map(pos2key).filter(k => k !== undefined);\n};\nexport const adjacentSquares = square => {\n  const pos = key2pos(square);\n  const adjacentSquares = [];\n  if (pos[0] > 0) adjacentSquares.push([pos[0] - 1, pos[1]]);\n  if (pos[0] < 7) adjacentSquares.push([pos[0] + 1, pos[1]]);\n  return adjacentSquares.map(pos2key).filter(k => k !== undefined);\n};\nexport const squareShiftedVertically = (square, delta) => {\n  const pos = key2pos(square);\n  pos[1] += delta;\n  return pos2key(pos);\n};\n//# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}