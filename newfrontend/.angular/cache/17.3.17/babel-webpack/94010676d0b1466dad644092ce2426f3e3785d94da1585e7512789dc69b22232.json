{"ast":null,"code":"/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nimport { Svg } from \"../lib/Svg.js\";\nimport { Utils } from \"../lib/Utils.js\";\nconst MOVE_INPUT_STATE = {\n  waitForInputStart: \"waitForInputStart\",\n  pieceClickedThreshold: \"pieceClickedThreshold\",\n  clickTo: \"clickTo\",\n  secondClickThreshold: \"secondClickThreshold\",\n  dragTo: \"dragTo\",\n  clickDragTo: \"clickDragTo\",\n  moveDone: \"moveDone\",\n  reset: \"reset\"\n};\nexport const MOVE_CANCELED_REASON = {\n  secondClick: \"secondClick\",\n  // clicked the same piece\n  secondaryClick: \"secondaryClick\",\n  // right click while moving\n  movedOutOfBoard: \"movedOutOfBoard\",\n  draggedBack: \"draggedBack\",\n  // dragged to the start square\n  clickedAnotherPiece: \"clickedAnotherPiece\" // of the same color\n};\nconst DRAG_THRESHOLD = 4;\nexport class VisualMoveInput {\n  constructor(view) {\n    this.view = view;\n    this.chessboard = view.chessboard;\n    this.moveInputState = null;\n    this.fromSquare = null;\n    this.toSquare = null;\n    this.setMoveInputState(MOVE_INPUT_STATE.waitForInputStart);\n  }\n  moveInputStartedCallback(square) {\n    const result = this.view.moveInputStartedCallback(square);\n    if (result) {\n      this.chessboard.state.moveInputProcess = Utils.createTask();\n      this.chessboard.state.moveInputProcess.then(result => {\n        if (this.moveInputState === MOVE_INPUT_STATE.waitForInputStart || this.moveInputState === MOVE_INPUT_STATE.moveDone) {\n          this.view.moveInputFinishedCallback(this.fromSquare, this.toSquare, result);\n        }\n      });\n    }\n    return result;\n  }\n  movingOverSquareCallback(fromSquare, toSquare) {\n    this.view.movingOverSquareCallback(fromSquare, toSquare);\n  }\n  validateMoveInputCallback(fromSquare, toSquare) {\n    const result = this.view.validateMoveInputCallback(fromSquare, toSquare);\n    this.chessboard.state.moveInputProcess.resolve(result);\n    return result;\n  }\n  moveInputCanceledCallback(fromSquare, toSquare, reason) {\n    this.view.moveInputCanceledCallback(fromSquare, toSquare, reason);\n    this.chessboard.state.moveInputProcess.resolve();\n  }\n  setMoveInputState(newState, params = undefined) {\n    const prevState = this.moveInputState;\n    this.moveInputState = newState;\n    switch (newState) {\n      case MOVE_INPUT_STATE.waitForInputStart:\n        break;\n      case MOVE_INPUT_STATE.pieceClickedThreshold:\n        if (MOVE_INPUT_STATE.waitForInputStart !== prevState && MOVE_INPUT_STATE.clickTo !== prevState) {\n          throw new Error(\"moveInputState\");\n        }\n        if (this.pointerMoveListener) {\n          removeEventListener(this.pointerMoveListener.type, this.pointerMoveListener);\n          this.pointerMoveListener = null;\n        }\n        if (this.pointerUpListener) {\n          removeEventListener(this.pointerUpListener.type, this.pointerUpListener);\n          this.pointerUpListener = null;\n        }\n        this.fromSquare = params.square;\n        this.toSquare = null;\n        this.movedPiece = params.piece;\n        this.startPoint = params.point;\n        if (!this.pointerMoveListener && !this.pointerUpListener) {\n          if (params.type === \"mousedown\") {\n            this.pointerMoveListener = this.onPointerMove.bind(this);\n            this.pointerMoveListener.type = \"mousemove\";\n            addEventListener(\"mousemove\", this.pointerMoveListener);\n            this.pointerUpListener = this.onPointerUp.bind(this);\n            this.pointerUpListener.type = \"mouseup\";\n            addEventListener(\"mouseup\", this.pointerUpListener);\n          } else if (params.type === \"touchstart\") {\n            this.pointerMoveListener = this.onPointerMove.bind(this);\n            this.pointerMoveListener.type = \"touchmove\";\n            addEventListener(\"touchmove\", this.pointerMoveListener);\n            this.pointerUpListener = this.onPointerUp.bind(this);\n            this.pointerUpListener.type = \"touchend\";\n            addEventListener(\"touchend\", this.pointerUpListener);\n          } else {\n            throw Error(\"4b74af\");\n          }\n          if (!this.contextMenuListener) {\n            this.contextMenuListener = this.onContextMenu.bind(this);\n            this.chessboard.view.svg.addEventListener(\"contextmenu\", this.contextMenuListener);\n          }\n        } else {\n          throw Error(\"94ad0c\");\n        }\n        break;\n      case MOVE_INPUT_STATE.clickTo:\n        if (this.draggablePiece) {\n          Svg.removeElement(this.draggablePiece);\n          this.draggablePiece = null;\n        }\n        if (prevState === MOVE_INPUT_STATE.dragTo) {\n          this.view.setPieceVisibility(params.square, true);\n        }\n        break;\n      case MOVE_INPUT_STATE.secondClickThreshold:\n        if (MOVE_INPUT_STATE.clickTo !== prevState) {\n          throw new Error(\"moveInputState\");\n        }\n        this.startPoint = params.point;\n        break;\n      case MOVE_INPUT_STATE.dragTo:\n        if (MOVE_INPUT_STATE.pieceClickedThreshold !== prevState) {\n          throw new Error(\"moveInputState\");\n        }\n        if (this.view.chessboard.state.inputEnabled()) {\n          this.view.setPieceVisibility(params.square, false);\n          this.createDraggablePiece(params.piece);\n        }\n        break;\n      case MOVE_INPUT_STATE.clickDragTo:\n        if (MOVE_INPUT_STATE.secondClickThreshold !== prevState) {\n          throw new Error(\"moveInputState\");\n        }\n        if (this.view.chessboard.state.inputEnabled()) {\n          this.view.setPieceVisibility(params.square, false);\n          this.createDraggablePiece(params.piece);\n        }\n        break;\n      case MOVE_INPUT_STATE.moveDone:\n        if ([MOVE_INPUT_STATE.dragTo, MOVE_INPUT_STATE.clickTo, MOVE_INPUT_STATE.clickDragTo].indexOf(prevState) === -1) {\n          throw new Error(\"moveInputState\");\n        }\n        this.toSquare = params.square;\n        if (this.toSquare && this.validateMoveInputCallback(this.fromSquare, this.toSquare)) {\n          this.chessboard.movePiece(this.fromSquare, this.toSquare, prevState === MOVE_INPUT_STATE.clickTo).then(() => {\n            if (prevState === MOVE_INPUT_STATE.clickTo) {\n              this.view.setPieceVisibility(this.toSquare, true);\n            }\n            this.setMoveInputState(MOVE_INPUT_STATE.reset);\n          });\n        } else {\n          this.view.setPieceVisibility(this.fromSquare, true);\n          this.setMoveInputState(MOVE_INPUT_STATE.reset);\n        }\n        break;\n      case MOVE_INPUT_STATE.reset:\n        if (this.fromSquare && !this.toSquare && this.movedPiece) {\n          this.chessboard.state.position.setPiece(this.fromSquare, this.movedPiece);\n        }\n        this.fromSquare = null;\n        this.toSquare = null;\n        this.movedPiece = null;\n        if (this.draggablePiece) {\n          Svg.removeElement(this.draggablePiece);\n          this.draggablePiece = null;\n        }\n        if (this.pointerMoveListener) {\n          removeEventListener(this.pointerMoveListener.type, this.pointerMoveListener);\n          this.pointerMoveListener = null;\n        }\n        if (this.pointerUpListener) {\n          removeEventListener(this.pointerUpListener.type, this.pointerUpListener);\n          this.pointerUpListener = null;\n        }\n        if (this.contextMenuListener) {\n          removeEventListener(\"contextmenu\", this.contextMenuListener);\n          this.contextMenuListener = null;\n        }\n        this.setMoveInputState(MOVE_INPUT_STATE.waitForInputStart);\n        // set temporarily hidden pieces visible again\n        const hiddenPieces = this.view.piecesGroup.querySelectorAll(\"[visibility=hidden]\");\n        for (let i = 0; i < hiddenPieces.length; i++) {\n          hiddenPieces[i].removeAttribute(\"visibility\");\n        }\n        break;\n      default:\n        throw Error(`260b09: moveInputState ${newState}`);\n    }\n  }\n  createDraggablePiece(pieceName) {\n    // maybe I should use the existing piece from the board and don't create a new one\n    if (this.draggablePiece) {\n      throw Error(\"draggablePiece already exists\");\n    }\n    this.draggablePiece = Svg.createSvg(document.body);\n    this.draggablePiece.classList.add(\"cm-chessboard-draggable-piece\");\n    this.draggablePiece.setAttribute(\"width\", this.view.squareWidth);\n    this.draggablePiece.setAttribute(\"height\", this.view.squareHeight);\n    this.draggablePiece.setAttribute(\"style\", \"pointer-events: none\");\n    this.draggablePiece.name = pieceName;\n    const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.view.getSpriteUrl();\n    const piece = Svg.addElement(this.draggablePiece, \"use\", {\n      href: `${spriteUrl}#${pieceName}`\n    });\n    const scaling = this.view.squareHeight / this.chessboard.props.style.pieces.tileSize;\n    const transformScale = this.draggablePiece.createSVGTransform();\n    transformScale.setScale(scaling, scaling);\n    piece.transform.baseVal.appendItem(transformScale);\n  }\n  moveDraggablePiece(x, y) {\n    this.draggablePiece.setAttribute(\"style\", `pointer-events: none; position: absolute; left: ${x - this.view.squareHeight / 2}px; top: ${y - this.view.squareHeight / 2}px`);\n  }\n  onPointerDown(e) {\n    if (!(e.type === \"mousedown\" && e.button === 0 || e.type === \"touchstart\")) {\n      return;\n    }\n    const square = e.target.getAttribute(\"data-square\");\n    if (!square) {\n      // pointer on square\n      return;\n    }\n    const pieceName = this.chessboard.getPiece(square);\n    let color;\n    if (pieceName) {\n      color = pieceName ? pieceName.substring(0, 1) : null;\n      // allow scrolling, if not pointed on draggable piece\n      if (color === \"w\" && this.chessboard.state.inputWhiteEnabled || color === \"b\" && this.chessboard.state.inputBlackEnabled) {\n        e.preventDefault();\n      }\n    }\n    if (this.moveInputState !== MOVE_INPUT_STATE.waitForInputStart || this.chessboard.state.inputWhiteEnabled && color === \"w\" || this.chessboard.state.inputBlackEnabled && color === \"b\") {\n      let point;\n      if (e.type === \"mousedown\") {\n        point = {\n          x: e.clientX,\n          y: e.clientY\n        };\n      } else if (e.type === \"touchstart\") {\n        point = {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY\n        };\n      }\n      if (this.moveInputState === MOVE_INPUT_STATE.waitForInputStart && pieceName && this.moveInputStartedCallback(square)) {\n        this.setMoveInputState(MOVE_INPUT_STATE.pieceClickedThreshold, {\n          square: square,\n          piece: pieceName,\n          point: point,\n          type: e.type\n        });\n      } else if (this.moveInputState === MOVE_INPUT_STATE.clickTo) {\n        if (square === this.fromSquare) {\n          this.setMoveInputState(MOVE_INPUT_STATE.secondClickThreshold, {\n            square: square,\n            piece: pieceName,\n            point: point,\n            type: e.type\n          });\n        } else {\n          const pieceName = this.chessboard.getPiece(square);\n          const pieceColor = pieceName ? pieceName.substring(0, 1) : null;\n          const startPieceName = this.chessboard.getPiece(this.fromSquare);\n          const startPieceColor = startPieceName ? startPieceName.substring(0, 1) : null;\n          if (color && startPieceColor === pieceColor) {\n            this.moveInputCanceledCallback(this.fromSquare, square, MOVE_CANCELED_REASON.clickedAnotherPiece);\n            if (this.moveInputStartedCallback(square)) {\n              this.setMoveInputState(MOVE_INPUT_STATE.pieceClickedThreshold, {\n                square: square,\n                piece: pieceName,\n                point: point,\n                type: e.type\n              });\n            } else {\n              this.setMoveInputState(MOVE_INPUT_STATE.reset);\n            }\n          } else {\n            this.setMoveInputState(MOVE_INPUT_STATE.moveDone, {\n              square: square\n            });\n          }\n        }\n      }\n    }\n  }\n  onPointerMove(e) {\n    let pageX, pageY, clientX, clientY, target;\n    if (e.type === \"mousemove\") {\n      clientX = e.clientX;\n      clientY = e.clientY;\n      pageX = e.pageX;\n      pageY = e.pageY;\n      target = e.target;\n    } else if (e.type === \"touchmove\") {\n      clientX = e.touches[0].clientX;\n      clientY = e.touches[0].clientY;\n      pageX = e.touches[0].pageX;\n      pageY = e.touches[0].pageY;\n      target = document.elementFromPoint(clientX, clientY);\n    }\n    if (this.moveInputState === MOVE_INPUT_STATE.pieceClickedThreshold || this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n      if (Math.abs(this.startPoint.x - clientX) > DRAG_THRESHOLD || Math.abs(this.startPoint.y - clientY) > DRAG_THRESHOLD) {\n        if (this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n          this.setMoveInputState(MOVE_INPUT_STATE.clickDragTo, {\n            square: this.fromSquare,\n            piece: this.movedPiece\n          });\n        } else {\n          this.setMoveInputState(MOVE_INPUT_STATE.dragTo, {\n            square: this.fromSquare,\n            piece: this.movedPiece\n          });\n        }\n        if (this.view.chessboard.state.inputEnabled()) {\n          this.moveDraggablePiece(pageX, pageY);\n        }\n      }\n    } else if (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo || this.moveInputState === MOVE_INPUT_STATE.clickTo) {\n      if (target && target.getAttribute && target.parentElement === this.view.boardGroup) {\n        const square = target.getAttribute(\"data-square\");\n        if (square !== this.fromSquare && square !== this.toSquare) {\n          this.toSquare = square;\n          this.movingOverSquareCallback(this.fromSquare, this.toSquare);\n        } else if (square === this.fromSquare && this.toSquare !== null) {\n          this.toSquare = null;\n          this.movingOverSquareCallback(this.fromSquare, null);\n        }\n      } else if (this.toSquare !== null) {\n        this.toSquare = null;\n        this.movingOverSquareCallback(this.fromSquare, null);\n      }\n      if (this.view.chessboard.state.inputEnabled() && (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo)) {\n        this.moveDraggablePiece(pageX, pageY);\n      }\n    }\n  }\n  onPointerUp(e) {\n    let target;\n    if (e.type === \"mouseup\") {\n      target = e.target;\n    } else if (e.type === \"touchend\") {\n      target = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n    }\n    if (target && target.getAttribute) {\n      const square = target.getAttribute(\"data-square\");\n      if (square) {\n        if (this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo) {\n          if (this.fromSquare === square) {\n            if (this.moveInputState === MOVE_INPUT_STATE.clickDragTo) {\n              this.chessboard.state.position.setPiece(this.fromSquare, this.movedPiece);\n              this.view.setPieceVisibility(this.fromSquare);\n              this.moveInputCanceledCallback(square, null, MOVE_CANCELED_REASON.draggedBack);\n              this.setMoveInputState(MOVE_INPUT_STATE.reset);\n            } else {\n              this.setMoveInputState(MOVE_INPUT_STATE.clickTo, {\n                square: square\n              });\n            }\n          } else {\n            this.setMoveInputState(MOVE_INPUT_STATE.moveDone, {\n              square: square\n            });\n          }\n        } else if (this.moveInputState === MOVE_INPUT_STATE.pieceClickedThreshold) {\n          this.setMoveInputState(MOVE_INPUT_STATE.clickTo, {\n            square: square\n          });\n        } else if (this.moveInputState === MOVE_INPUT_STATE.secondClickThreshold) {\n          this.setMoveInputState(MOVE_INPUT_STATE.reset);\n          this.moveInputCanceledCallback(square, null, MOVE_CANCELED_REASON.secondClick);\n        }\n      } else {\n        this.view.redrawPieces();\n        const moveStartSquare = this.fromSquare;\n        this.setMoveInputState(MOVE_INPUT_STATE.reset);\n        this.moveInputCanceledCallback(moveStartSquare, null, MOVE_CANCELED_REASON.movedOutOfBoard);\n      }\n    } else {\n      this.view.redrawPieces();\n      this.setMoveInputState(MOVE_INPUT_STATE.reset);\n    }\n  }\n  onContextMenu(e) {\n    // while moving\n    e.preventDefault();\n    this.view.redrawPieces();\n    this.setMoveInputState(MOVE_INPUT_STATE.reset);\n    this.moveInputCanceledCallback(this.fromSquare, null, MOVE_CANCELED_REASON.secondaryClick);\n  }\n  isDragging() {\n    return this.moveInputState === MOVE_INPUT_STATE.dragTo || this.moveInputState === MOVE_INPUT_STATE.clickDragTo;\n  }\n  destroy() {\n    this.setMoveInputState(MOVE_INPUT_STATE.reset);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}