{"ast":null,"code":"/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-chessboard\n * License: MIT, see file 'LICENSE'\n */\n\nimport { VisualMoveInput } from \"./VisualMoveInput.js\";\nimport { Position } from \"../model/Position.js\";\nimport { EXTENSION_POINT } from \"../model/Extension.js\";\nimport { Svg } from \"../lib/Svg.js\";\nimport { Utils } from \"../lib/Utils.js\";\nexport const COLOR = {\n  white: \"w\",\n  black: \"b\"\n};\nexport const INPUT_EVENT_TYPE = {\n  moveInputStarted: \"moveInputStarted\",\n  movingOverSquare: \"movingOverSquare\",\n  // while dragging or hover after click\n  validateMoveInput: \"validateMoveInput\",\n  moveInputCanceled: \"moveInputCanceled\",\n  moveInputFinished: \"moveInputFinished\"\n};\nexport const POINTER_EVENTS = {\n  pointercancel: \"pointercancel\",\n  pointerdown: \"pointerdown\",\n  pointerenter: \"pointerenter\",\n  pointerleave: \"pointerleave\",\n  pointermove: \"pointermove\",\n  pointerout: \"pointerout\",\n  pointerover: \"pointerover\",\n  pointerup: \"pointerup\"\n};\nexport const BORDER_TYPE = {\n  none: \"none\",\n  // no border\n  thin: \"thin\",\n  // thin border\n  frame: \"frame\" // wide border with coordinates in it\n};\nexport class ChessboardView {\n  constructor(chessboard) {\n    this.chessboard = chessboard;\n    this.visualMoveInput = new VisualMoveInput(this);\n    if (chessboard.props.assetsCache) {\n      this.cacheSpriteToDiv(\"cm-chessboard-sprite\", this.getSpriteUrl());\n    }\n    this.container = document.createElement(\"div\");\n    this.chessboard.context.appendChild(this.container);\n    if (chessboard.props.responsive) {\n      if (typeof ResizeObserver !== \"undefined\") {\n        this.resizeObserver = new ResizeObserver(() => {\n          setTimeout(() => {\n            // prevents \"ResizeObserver loop completed with undelivered notifications.\"\n            this.handleResize();\n          });\n        });\n        this.resizeObserver.observe(this.chessboard.context);\n      } else {\n        this.resizeListener = this.handleResize.bind(this);\n        window.addEventListener(\"resize\", this.resizeListener);\n      }\n    }\n    this.positionsAnimationTask = Promise.resolve();\n    this.pointerDownListener = this.pointerDownHandler.bind(this);\n    this.container.addEventListener(\"mousedown\", this.pointerDownListener);\n    this.container.addEventListener(\"touchstart\", this.pointerDownListener, {\n      passive: false\n    });\n    this.createSvgAndGroups();\n    this.handleResize();\n  }\n  pointerDownHandler(e) {\n    this.visualMoveInput.onPointerDown(e);\n  }\n  destroy() {\n    this.visualMoveInput.destroy();\n    if (this.resizeObserver) {\n      this.resizeObserver.unobserve(this.chessboard.context);\n    }\n    if (this.resizeListener) {\n      window.removeEventListener(\"resize\", this.resizeListener);\n    }\n    this.chessboard.context.removeEventListener(\"mousedown\", this.pointerDownListener);\n    this.chessboard.context.removeEventListener(\"touchstart\", this.pointerDownListener);\n    Svg.removeElement(this.svg);\n    this.container.remove();\n  }\n\n  // Sprite //\n\n  cacheSpriteToDiv(wrapperId, url) {\n    if (!document.getElementById(wrapperId)) {\n      const wrapper = document.createElement(\"div\");\n      wrapper.style.transform = \"scale(0)\";\n      wrapper.style.position = \"absolute\";\n      wrapper.setAttribute(\"aria-hidden\", \"true\");\n      wrapper.id = wrapperId;\n      document.body.appendChild(wrapper);\n      const xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", url, true);\n      xhr.onload = function () {\n        wrapper.insertAdjacentHTML('afterbegin', xhr.response);\n      };\n      xhr.send();\n    }\n  }\n  createSvgAndGroups() {\n    this.svg = Svg.createSvg(this.container);\n    // let description = document.createElement(\"description\")\n    // description.innerText = \"Chessboard\"\n    // description.id = \"svg-description\"\n    // this.svg.appendChild(description)\n    let cssClass = this.chessboard.props.style.cssClass ? this.chessboard.props.style.cssClass : \"default\";\n    this.svg.setAttribute(\"class\", \"cm-chessboard border-type-\" + this.chessboard.props.style.borderType + \" \" + cssClass);\n    // this.svg.setAttribute(\"aria-describedby\", \"svg-description\")\n    this.svg.setAttribute(\"role\", \"img\");\n    this.updateMetrics();\n    this.boardGroup = Svg.addElement(this.svg, \"g\", {\n      class: \"board\"\n    });\n    this.coordinatesGroup = Svg.addElement(this.svg, \"g\", {\n      class: \"coordinates\",\n      \"aria-hidden\": \"true\"\n    });\n    this.markersLayer = Svg.addElement(this.svg, \"g\", {\n      class: \"markers-layer\"\n    });\n    this.piecesLayer = Svg.addElement(this.svg, \"g\", {\n      class: \"pieces-layer\"\n    });\n    this.piecesGroup = Svg.addElement(this.piecesLayer, \"g\", {\n      class: \"pieces\"\n    });\n    this.markersTopLayer = Svg.addElement(this.svg, \"g\", {\n      class: \"markers-top-layer\"\n    });\n    this.interactiveTopLayer = Svg.addElement(this.svg, \"g\", {\n      class: \"interactive-top-layer\"\n    });\n  }\n  updateMetrics() {\n    const piecesTileSize = this.chessboard.props.style.pieces.tileSize;\n    this.width = this.container.clientWidth;\n    this.height = this.container.clientWidth * (this.chessboard.props.style.aspectRatio || 1);\n    if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n      this.borderSize = this.width / 25;\n    } else if (this.chessboard.props.style.borderType === BORDER_TYPE.thin) {\n      this.borderSize = this.width / 320;\n    } else {\n      this.borderSize = 0;\n    }\n    this.innerWidth = this.width - 2 * this.borderSize;\n    this.innerHeight = this.height - 2 * this.borderSize;\n    this.squareWidth = this.innerWidth / 8;\n    this.squareHeight = this.innerHeight / 8;\n    this.scalingX = this.squareWidth / piecesTileSize;\n    this.scalingY = this.squareHeight / piecesTileSize;\n    this.pieceXTranslate = this.squareWidth / 2 - piecesTileSize * this.scalingY / 2;\n  }\n  handleResize() {\n    this.container.style.width = this.chessboard.context.clientWidth + \"px\";\n    this.container.style.height = this.chessboard.context.clientWidth * this.chessboard.props.style.aspectRatio + \"px\";\n    if (this.container.clientWidth !== this.width || this.container.clientHeight !== this.height) {\n      this.updateMetrics();\n      this.redrawBoard();\n      this.redrawPieces();\n    }\n    this.svg.setAttribute(\"width\", \"100%\");\n    this.svg.setAttribute(\"height\", \"100%\");\n  }\n  redrawBoard() {\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.beforeRedrawBoard);\n    this.redrawSquares();\n    this.drawCoordinates();\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.afterRedrawBoard);\n    this.visualizeInputState();\n  }\n\n  // Board //\n\n  redrawSquares() {\n    while (this.boardGroup.firstChild) {\n      this.boardGroup.removeChild(this.boardGroup.lastChild);\n    }\n    let boardBorder = Svg.addElement(this.boardGroup, \"rect\", {\n      width: this.width,\n      height: this.height\n    });\n    boardBorder.setAttribute(\"class\", \"border\");\n    if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n      const innerPos = this.borderSize;\n      let borderInner = Svg.addElement(this.boardGroup, \"rect\", {\n        x: innerPos,\n        y: innerPos,\n        width: this.width - innerPos * 2,\n        height: this.height - innerPos * 2\n      });\n      borderInner.setAttribute(\"class\", \"border-inner\");\n    }\n    for (let i = 0; i < 64; i++) {\n      const index = this.chessboard.state.orientation === COLOR.white ? i : 63 - i;\n      const squareColor = (9 * index & 8) === 0 ? 'black' : 'white';\n      const fieldClass = `square ${squareColor}`;\n      const point = this.squareToPoint(Position.indexToSquare(index));\n      const squareRect = Svg.addElement(this.boardGroup, \"rect\", {\n        x: point.x,\n        y: point.y,\n        width: this.squareWidth,\n        height: this.squareHeight\n      });\n      squareRect.setAttribute(\"class\", fieldClass);\n      squareRect.setAttribute(\"data-square\", Position.indexToSquare(index));\n    }\n  }\n  drawCoordinates() {\n    if (!this.chessboard.props.style.showCoordinates) {\n      return;\n    }\n    while (this.coordinatesGroup.firstChild) {\n      this.coordinatesGroup.removeChild(this.coordinatesGroup.lastChild);\n    }\n    const inline = this.chessboard.props.style.borderType !== BORDER_TYPE.frame;\n    for (let file = 0; file < 8; file++) {\n      let x = this.borderSize + (17 + this.chessboard.props.style.pieces.tileSize * file) * this.scalingX;\n      let y = this.height - this.scalingY * 3.5;\n      let cssClass = \"coordinate file\";\n      if (inline) {\n        x = x + this.scalingX * 15.5;\n        cssClass += file % 2 ? \" white\" : \" black\";\n      }\n      const textElement = Svg.addElement(this.coordinatesGroup, \"text\", {\n        class: cssClass,\n        x: x,\n        y: y,\n        style: `font-size: ${this.scalingY * 10}px`\n      });\n      if (this.chessboard.state.orientation === COLOR.white) {\n        textElement.textContent = String.fromCharCode(97 + file);\n      } else {\n        textElement.textContent = String.fromCharCode(104 - file);\n      }\n    }\n    for (let rank = 0; rank < 8; rank++) {\n      let x = this.borderSize / 3.7;\n      let y = this.borderSize + 25 * this.scalingY + rank * this.squareHeight;\n      let cssClass = \"coordinate rank\";\n      if (inline) {\n        cssClass += rank % 2 ? \" black\" : \" white\";\n        if (this.chessboard.props.style.borderType === BORDER_TYPE.frame) {\n          x = x + this.scalingX * 10;\n          y = y - this.scalingY * 15;\n        } else {\n          x = x + this.scalingX * 2;\n          y = y - this.scalingY * 15;\n        }\n      }\n      const textElement = Svg.addElement(this.coordinatesGroup, \"text\", {\n        class: cssClass,\n        x: x,\n        y: y,\n        style: `font-size: ${this.scalingY * 10}px`\n      });\n      if (this.chessboard.state.orientation === COLOR.white) {\n        textElement.textContent = \"\" + (8 - rank);\n      } else {\n        textElement.textContent = \"\" + (1 + rank);\n      }\n    }\n  }\n\n  // Pieces //\n\n  redrawPieces(squares = this.chessboard.state.position.squares) {\n    const childNodes = Array.from(this.piecesGroup.childNodes);\n    const isDragging = this.visualMoveInput.isDragging();\n    for (let i = 0; i < 64; i++) {\n      const pieceName = squares[i];\n      if (pieceName) {\n        const square = Position.indexToSquare(i);\n        this.drawPieceOnSquare(square, pieceName, isDragging && square === this.visualMoveInput.fromSquare);\n      }\n    }\n    for (const childNode of childNodes) {\n      this.piecesGroup.removeChild(childNode);\n    }\n  }\n  drawPiece(parentGroup, pieceName, point) {\n    const pieceGroup = Svg.addElement(parentGroup, \"g\", {});\n    pieceGroup.setAttribute(\"data-piece\", pieceName);\n    const transform = this.svg.createSVGTransform();\n    transform.setTranslate(point.x, point.y);\n    pieceGroup.transform.baseVal.appendItem(transform);\n    const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl();\n    const pieceUse = Svg.addElement(pieceGroup, \"use\", {\n      href: `${spriteUrl}#${pieceName}`,\n      class: \"piece\"\n    });\n    const transformScale = this.svg.createSVGTransform();\n    transformScale.setScale(this.scalingY, this.scalingY);\n    pieceUse.transform.baseVal.appendItem(transformScale);\n    return pieceGroup;\n  }\n  drawPieceOnSquare(square, pieceName, hidden = false) {\n    const pieceGroup = Svg.addElement(this.piecesGroup, \"g\", {});\n    pieceGroup.setAttribute(\"data-piece\", pieceName);\n    pieceGroup.setAttribute(\"data-square\", square);\n    if (hidden) {\n      pieceGroup.setAttribute(\"visibility\", \"hidden\");\n    }\n    const point = this.squareToPoint(square);\n    const transform = this.svg.createSVGTransform();\n    transform.setTranslate(point.x, point.y);\n    pieceGroup.transform.baseVal.appendItem(transform);\n    const spriteUrl = this.chessboard.props.assetsCache ? \"\" : this.getSpriteUrl();\n    const pieceUse = Svg.addElement(pieceGroup, \"use\", {\n      href: `${spriteUrl}#${pieceName}`,\n      class: \"piece\"\n    });\n    // center on square\n    const transformTranslate = this.svg.createSVGTransform();\n    transformTranslate.setTranslate(this.pieceXTranslate, 0);\n    pieceUse.transform.baseVal.appendItem(transformTranslate);\n    // scale\n    const transformScale = this.svg.createSVGTransform();\n    transformScale.setScale(this.scalingY, this.scalingY);\n    pieceUse.transform.baseVal.appendItem(transformScale);\n    return pieceGroup;\n  }\n  setPieceVisibility(square, visible = true) {\n    const piece = this.getPieceElement(square);\n    if (piece) {\n      if (visible) {\n        piece.setAttribute(\"visibility\", \"visible\");\n      } else {\n        piece.setAttribute(\"visibility\", \"hidden\");\n      }\n    } else {\n      console.warn(\"no piece on\", square);\n    }\n  }\n  getPieceElement(square) {\n    if (!square || square.length < 2) {\n      console.warn(\"invalid square\", square);\n      return null;\n    }\n    const piece = this.piecesGroup.querySelector(`g[data-square='${square}']`);\n    if (!piece) {\n      console.warn(\"no piece on\", square);\n      return null;\n    }\n    return piece;\n  }\n\n  // enable and disable move input //\n\n  enableMoveInput(eventHandler, color = null) {\n    if (this.chessboard.state.moveInputCallback) {\n      throw Error(\"moveInput already enabled\");\n    }\n    if (color === COLOR.white) {\n      this.chessboard.state.inputWhiteEnabled = true;\n    } else if (color === COLOR.black) {\n      this.chessboard.state.inputBlackEnabled = true;\n    } else {\n      this.chessboard.state.inputWhiteEnabled = true;\n      this.chessboard.state.inputBlackEnabled = true;\n    }\n    this.chessboard.state.moveInputCallback = eventHandler;\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.moveInputToggled, {\n      enabled: true,\n      color: color\n    });\n    this.visualizeInputState();\n  }\n  disableMoveInput() {\n    this.chessboard.state.inputWhiteEnabled = false;\n    this.chessboard.state.inputBlackEnabled = false;\n    this.chessboard.state.moveInputCallback = null;\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.moveInputToggled, {\n      enabled: false\n    });\n    this.visualizeInputState();\n  }\n\n  // callbacks //\n\n  moveInputStartedCallback(square) {\n    const data = {\n      chessboard: this.chessboard,\n      type: INPUT_EVENT_TYPE.moveInputStarted,\n      square: square,\n      /** square is deprecated, use squareFrom (2023-05-22) */\n      squareFrom: square,\n      piece: this.chessboard.getPiece(square)\n    };\n    if (this.chessboard.state.moveInputCallback) {\n      data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data);\n    }\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.moveInput, data);\n    return data.moveInputCallbackResult;\n  }\n  movingOverSquareCallback(squareFrom, squareTo) {\n    const data = {\n      chessboard: this.chessboard,\n      type: INPUT_EVENT_TYPE.movingOverSquare,\n      squareFrom: squareFrom,\n      squareTo: squareTo,\n      piece: this.chessboard.getPiece(squareFrom)\n    };\n    if (this.chessboard.state.moveInputCallback) {\n      data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data);\n    }\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.moveInput, data);\n  }\n  validateMoveInputCallback(squareFrom, squareTo) {\n    const data = {\n      chessboard: this.chessboard,\n      type: INPUT_EVENT_TYPE.validateMoveInput,\n      squareFrom: squareFrom,\n      squareTo: squareTo,\n      piece: this.chessboard.getPiece(squareFrom)\n    };\n    if (this.chessboard.state.moveInputCallback) {\n      data.moveInputCallbackResult = this.chessboard.state.moveInputCallback(data);\n    }\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.moveInput, data);\n    return data.moveInputCallbackResult;\n  }\n  moveInputCanceledCallback(squareFrom, squareTo, reason) {\n    const data = {\n      chessboard: this.chessboard,\n      type: INPUT_EVENT_TYPE.moveInputCanceled,\n      reason: reason,\n      squareFrom: squareFrom,\n      squareTo: squareTo\n    };\n    if (this.chessboard.state.moveInputCallback) {\n      this.chessboard.state.moveInputCallback(data);\n    }\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.moveInput, data);\n  }\n  moveInputFinishedCallback(squareFrom, squareTo, legalMove) {\n    const data = {\n      chessboard: this.chessboard,\n      type: INPUT_EVENT_TYPE.moveInputFinished,\n      squareFrom: squareFrom,\n      squareTo: squareTo,\n      legalMove: legalMove\n    };\n    if (this.chessboard.state.moveInputCallback) {\n      this.chessboard.state.moveInputCallback(data);\n    }\n    this.chessboard.state.invokeExtensionPoints(EXTENSION_POINT.moveInput, data);\n  }\n\n  // Helpers //\n\n  visualizeInputState() {\n    if (this.chessboard.state) {\n      // fix https://github.com/shaack/cm-chessboard/issues/47\n      if (this.chessboard.state.inputWhiteEnabled || this.chessboard.state.inputBlackEnabled) {\n        this.boardGroup.setAttribute(\"class\", \"board input-enabled\");\n      } else {\n        this.boardGroup.setAttribute(\"class\", \"board\");\n      }\n    }\n  }\n  indexToPoint(index) {\n    let x, y;\n    if (this.chessboard.state.orientation === COLOR.white) {\n      x = this.borderSize + index % 8 * this.squareWidth;\n      y = this.borderSize + (7 - Math.floor(index / 8)) * this.squareHeight;\n    } else {\n      x = this.borderSize + (7 - index % 8) * this.squareWidth;\n      y = this.borderSize + Math.floor(index / 8) * this.squareHeight;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  squareToPoint(square) {\n    const index = Position.squareToIndex(square);\n    return this.indexToPoint(index);\n  }\n  getSpriteUrl() {\n    if (Utils.isAbsoluteUrl(this.chessboard.props.style.pieces.file)) {\n      return this.chessboard.props.style.pieces.file;\n    } else {\n      return this.chessboard.props.assetsUrl + this.chessboard.props.style.pieces.file;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}